// lex.yy.cpp generated by reflex 1.4.0 from lexer.l

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_flex                true
#define REFLEX_OPTION_lex                 yylex
#define REFLEX_OPTION_lexer               yyFlexLexer
#define REFLEX_OPTION_main                true
#define REFLEX_OPTION_nodefault           true
#define REFLEX_OPTION_outfile             "lex.yy.cpp"
#define REFLEX_OPTION_prefix              yy

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE DEFINITIONS                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define INITIAL (0)
#define YY_NUM_RULES (59)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE ABSTRACT LEXER CLASS                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/flexlexer.h>
typedef reflex::FlexLexer<reflex::Matcher> FlexLexer;

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class yyFlexLexer : public FlexLexer {
 public:
  yyFlexLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream        *os    = NULL)
    :
      FlexLexer(input, os)
  {
  }
  virtual int yylex();
  int yylex(
      const reflex::Input& input,
      std::ostream        *os = NULL)
  {
    in(input);
    if (os)
      out(*os);
    return yylex();
  }
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "lexer.l"
// C/C++ tokenizer (plain, no Unicode)


#include
<stdio.h>


#line 13 "lexer.l"
/* may add %option unicode before the %include to match unicode identifiers */

#line 15 "lexer.l"
// %include "cdefs.l" // That is the definisions below

#line 17 "lexer.l"
// Requires RE/flex matcher or a Perl/ECMA matcher that supports lazy quants


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

extern void reflex_code_INITIAL(reflex::Matcher&);

int yyFlexLexer::yylex()
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
    YY_USER_INIT
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              LexerError("scanner jammed");
              yyterminate();
            }
            YY_BREAK
          case 1: // rule at line 37: (?:[\x09-\x0d\x20]+)
            YY_USER_ACTION
#line 37 "lexer.l"
            YY_BREAK
          case 2: // rule at line 38: (?:(?:\Q//\E)(?:[^\x0a]|\\\n)*\n)
            YY_USER_ACTION
#line 38 "lexer.l"
            YY_BREAK
          case 3: // rule at line 39: (?:(?:\Q/*\E)(?:.|\n)*?(?:\Q*/\E))
            YY_USER_ACTION
#line 39 "lexer.l"
            YY_BREAK
          case 4: // rule at line 40: (?:^[\x09\x20]*#(?:[^\x0a]|\\\r?\n)+)
            YY_USER_ACTION
#line 40 "lexer.l"
printf("DIRECTIVE %s\n", yytext);
            YY_BREAK
          case 5: // rule at line 41: (?:[A-Z_a-z][0-9A-Z_a-z]*)
            YY_USER_ACTION
#line 41 "lexer.l"
printf("NAME      %s\n", yytext);
            YY_BREAK
          case 6: // rule at line 42: (?:\d*(?:\d|\.\d|\d\.)\d*(?:[Ee][\x2b\x2d]?\d+)?[FLfl]?)
            YY_USER_ACTION
#line 42 "lexer.l"
printf("FLOAT     %s\n", yytext);
            YY_BREAK
          case 7: // rule at line 43: (?:(?:(?:0[0-7]+)|(?:0[Xx][0-9A-Fa-f]+)|(?:0|[1-9]\d*))(?:[Ll]{0,2}[Uu]?|[Uu][Ll]{0,2}))
            YY_USER_ACTION
#line 43 "lexer.l"
printf("INT       %s\n", yytext);
            YY_BREAK
          case 8: // rule at line 44: (?:L?'(?:\\.|[^\x0a'\x5c])*')
            YY_USER_ACTION
#line 44 "lexer.l"
printf("CHAR      %s\n", yytext);
            YY_BREAK
          case 9: // rule at line 45: (?:L?"(?:\\.|\\\r?\n|[^\x0a"\x5c])*")
            YY_USER_ACTION
#line 45 "lexer.l"
printf("STRING    %s\n", yytext);
            YY_BREAK
          case 10: // rule at line 46: (?:\Q{\E)|(?:\Q<%\E)
          case 11: // rule at line 47: (?:\Q}\E)|(?:\Q%>\E)
          case 12: // rule at line 48: (?:\Q[\E)|(?:\Q<:\E)
          case 13: // rule at line 49: (?:\Q]\E)|(?:\Q:>\E)
          case 14: // rule at line 50: (?:\Q(\E)
          case 15: // rule at line 51: (?:\Q)\E)
          case 16: // rule at line 52: (?:\Q+=\E)
          case 17: // rule at line 53: (?:\Q++\E)
          case 18: // rule at line 54: (?:\Q+\E)
          case 19: // rule at line 55: (?:\Q-=\E)
          case 20: // rule at line 56: (?:\Q--\E)
          case 21: // rule at line 57: (?:\Q->*\E)
          case 22: // rule at line 58: (?:\Q->\E)
          case 23: // rule at line 59: (?:\Q-\E)
          case 24: // rule at line 60: (?:\Q==\E)
          case 25: // rule at line 61: (?:\Q=\E)
          case 26: // rule at line 62: (?:\Q<=\E)
          case 27: // rule at line 63: (?:\Q<<=\E)
          case 28: // rule at line 64: (?:\Q<<\E)
          case 29: // rule at line 65: (?:\Q<\E)
          case 30: // rule at line 66: (?:\Q>=\E)
          case 31: // rule at line 67: (?:\Q>>=\E)
          case 32: // rule at line 68: (?:\Q>>\E)
          case 33: // rule at line 69: (?:\Q>\E)
          case 34: // rule at line 70: (?:\Q!=\E)
          case 35: // rule at line 71: (?:\Q!\E)
          case 36: // rule at line 72: (?:\Q,\E)
          case 37: // rule at line 73: (?:\Q;\E)
          case 38: // rule at line 74: (?:\Q...\E)
          case 39: // rule at line 75: (?:\Q.*\E)
          case 40: // rule at line 76: (?:\Q.\E)
          case 41: // rule at line 77: (?:\Q^=\E)
          case 42: // rule at line 78: (?:\Q^\E)
          case 43: // rule at line 79: (?:\Q~\E)
          case 44: // rule at line 80: (?:\Q*=\E)
          case 45: // rule at line 81: (?:\Q*\E)
          case 46: // rule at line 82: (?:\Q/=\E)
          case 47: // rule at line 83: (?:\Q/\E)
          case 48: // rule at line 84: (?:\Q%=\E)
          case 49: // rule at line 85: (?:\Q%\E)
          case 50: // rule at line 86: (?:\Q&=\E)
          case 51: // rule at line 87: (?:\Q&&\E)
          case 52: // rule at line 88: (?:\Q&\E)
          case 53: // rule at line 89: (?:\Q|=\E)
          case 54: // rule at line 90: (?:\Q||\E)
          case 55: // rule at line 91: (?:\Q|\E)
          case 56: // rule at line 92: (?:\Q::\E)
          case 57: // rule at line 93: (?:\Q:\E)
          case 58: // rule at line 94: (?:\Q?\E)
            YY_USER_ACTION
#line 94 "lexer.l"
printf("PUNCT     %s\n", yytext);
            YY_BREAK
          case 59: // rule at line 95: .
            YY_USER_ACTION
#line 95 "lexer.l"
printf("*** ERROR '%s' at line %d\n", yytext, yylineno);

            YY_BREAK
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: main                                                           //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

int main()
{
  return yyFlexLexer().yylex();
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 98 "lexer.l"


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-label"
#endif

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = c0;
  m.FSM_INIT(c1);

S0:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '~') goto S149;
  if (c1 == '}') goto S105;
  if (c1 == '|') goto S158;
  if (c1 == '{') goto S97;
  if ('a' <= c1 && c1 <= 'z') goto S47;
  if (c1 == '_') goto S47;
  if (c1 == '^') goto S146;
  if (c1 == ']') goto S113;
  if (c1 == '[') goto S111;
  if (c1 == 'L') goto S176;
  if ('A' <= c1 && c1 <= 'Z') goto S47;
  if (c1 == '?') goto S162;
  if (c1 == '>') goto S135;
  if (c1 == '=') goto S132;
  if (c1 == '<') goto S99;
  if (c1 == ';') goto S144;
  if (c1 == ':') goto S115;
  if ('1' <= c1 && c1 <= '9') goto S53;
  if (c1 == '0') goto S70;
  if (c1 == '/') goto S37;
  if (c1 == '.') goto S65;
  if (c1 == '-') goto S127;
  if (c1 == ',') goto S142;
  if (c1 == '+') goto S123;
  if (c1 == '*') goto S151;
  if (c1 == ')') goto S121;
  if (c1 == '(') goto S119;
  if (c1 == '\'') goto S85;
  if (c1 == '&') goto S154;
  if (c1 == '%') goto S107;
  if (c1 == '#') goto S42;
  if (c1 == '"') goto S91;
  if (c1 == '!') goto S139;
  if (c1 == ' ') goto S170;
  if ('\n' <= c1 && c1 <= '\r') goto S166;
  if (c1 == '\t') goto S170;
  if ('\0' <= c1) goto S164;
  return m.FSM_HALT(c1);

S37:
  m.FSM_TAKE(47);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S189;
  if (c1 == '/') goto S184;
  if (c1 == '*') goto S187;
  return m.FSM_HALT(c1);

S42:
  m.FSM_TAKE(59);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S196;
  if ('\v' <= c1) goto S191;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S191;
  return m.FSM_HALT(c1);

S47:
  m.FSM_TAKE(5);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S47;
  if (c1 == '_') goto S47;
  if ('A' <= c1 && c1 <= 'Z') goto S47;
  if ('0' <= c1 && c1 <= '9') goto S47;
  return m.FSM_HALT(c1);

S53:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S209;
  if (c1 == 'l') goto S219;
  if (c1 == 'f') goto S217;
  if (c1 == 'e') goto S213;
  if (c1 == 'U') goto S209;
  if (c1 == 'L') goto S219;
  if (c1 == 'F') goto S217;
  if (c1 == 'E') goto S213;
  if ('0' <= c1 && c1 <= '9') goto S53;
  if (c1 == '.') goto S200;
  return m.FSM_HALT(c1);

S65:
  m.FSM_TAKE(40);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S225;
  if (c1 == '.') goto S234;
  if (c1 == '*') goto S236;
  return m.FSM_HALT(c1);

S70:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'x') goto S248;
  if (c1 == 'u') goto S209;
  if (c1 == 'l') goto S219;
  if (c1 == 'f') goto S217;
  if (c1 == 'e') goto S213;
  if (c1 == 'X') goto S248;
  if (c1 == 'U') goto S209;
  if (c1 == 'L') goto S219;
  if (c1 == 'F') goto S217;
  if (c1 == 'E') goto S213;
  if ('8' <= c1 && c1 <= '9') goto S238;
  if ('0' <= c1 && c1 <= '7') goto S252;
  if (c1 == '.') goto S200;
  return m.FSM_HALT(c1);

S85:
  m.FSM_TAKE(59);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S267;
  if (c1 == '\'') goto S265;
  if ('\v' <= c1) goto S270;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S270;
  return m.FSM_HALT(c1);

S91:
  m.FSM_TAKE(59);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S277;
  if (c1 == '"') goto S275;
  if ('\v' <= c1) goto S279;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S279;
  return m.FSM_HALT(c1);

S97:
  m.FSM_TAKE(10);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S99:
  m.FSM_TAKE(29);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S284;
  if (c1 == '<') goto S286;
  if (c1 == ':') goto S111;
  if (c1 == '%') goto S97;
  return m.FSM_HALT(c1);

S105:
  m.FSM_TAKE(11);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S107:
  m.FSM_TAKE(49);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '>') goto S105;
  if (c1 == '=') goto S289;
  return m.FSM_HALT(c1);

S111:
  m.FSM_TAKE(12);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S113:
  m.FSM_TAKE(13);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S115:
  m.FSM_TAKE(57);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '>') goto S113;
  if (c1 == ':') goto S291;
  return m.FSM_HALT(c1);

S119:
  m.FSM_TAKE(14);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S121:
  m.FSM_TAKE(15);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S123:
  m.FSM_TAKE(18);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S293;
  if (c1 == '+') goto S295;
  return m.FSM_HALT(c1);

S127:
  m.FSM_TAKE(23);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '>') goto S301;
  if (c1 == '=') goto S297;
  if (c1 == '-') goto S299;
  return m.FSM_HALT(c1);

S132:
  m.FSM_TAKE(25);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S304;
  return m.FSM_HALT(c1);

S135:
  m.FSM_TAKE(33);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '>') goto S308;
  if (c1 == '=') goto S306;
  return m.FSM_HALT(c1);

S139:
  m.FSM_TAKE(35);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S311;
  return m.FSM_HALT(c1);

S142:
  m.FSM_TAKE(36);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S144:
  m.FSM_TAKE(37);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S146:
  m.FSM_TAKE(42);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S313;
  return m.FSM_HALT(c1);

S149:
  m.FSM_TAKE(43);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S151:
  m.FSM_TAKE(45);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S315;
  return m.FSM_HALT(c1);

S154:
  m.FSM_TAKE(52);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S317;
  if (c1 == '&') goto S319;
  return m.FSM_HALT(c1);

S158:
  m.FSM_TAKE(55);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '|') goto S323;
  if (c1 == '=') goto S321;
  return m.FSM_HALT(c1);

S162:
  m.FSM_TAKE(58);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S164:
  m.FSM_TAKE(59);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S166:
  m.FSM_TAKE(1);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S166;
  if ('\t' <= c1 && c1 <= '\r') goto S166;
  return m.FSM_HALT(c1);

S170:
  m.FSM_TAKE(1);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '#') goto S325;
  if (c1 == ' ') goto S170;
  if ('\n' <= c1 && c1 <= '\r') goto S166;
  if (c1 == '\t') goto S170;
  return m.FSM_HALT(c1);

S176:
  m.FSM_TAKE(5);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S47;
  if (c1 == '_') goto S47;
  if ('A' <= c1 && c1 <= 'Z') goto S47;
  if ('0' <= c1 && c1 <= '9') goto S47;
  if (c1 == '\'') goto S270;
  if (c1 == '"') goto S279;
  return m.FSM_HALT(c1);

S184:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S331;
  if (c1 == '\n') goto S329;
  if ('\0' <= c1) goto S184;
  return m.FSM_HALT(c1);

S187:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '*') goto S334;
  if ('\0' <= c1) goto S337;
  return m.FSM_HALT(c1);

S189:
  m.FSM_TAKE(46);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S191:
  c0 = c1, c1 = m.FSM_CHAR();
  if (m.FSM_META_BOL()) {
    m.FSM_TAKE(4, c1);
  }
  if (c1 == '\\') goto S196;
  if ('\v' <= c1) goto S191;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S191;
  return m.FSM_HALT(c1);

S196:
  c0 = c1, c1 = m.FSM_CHAR();
  if (m.FSM_META_BOL()) {
    m.FSM_TAKE(4, c1);
  }
  if (c1 == '\\') goto S196;
  if (c1 == '\r') goto S341;
  if ('\0' <= c1) goto S191;
  return m.FSM_HALT(c1);

S200:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S217;
  if (c1 == 'f') goto S217;
  if (c1 == 'e') goto S213;
  if (c1 == 'L') goto S217;
  if (c1 == 'F') goto S217;
  if (c1 == 'E') goto S213;
  if ('0' <= c1 && c1 <= '9') goto S225;
  return m.FSM_HALT(c1);

S209:
  m.FSM_TAKE(7);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S344;
  if (c1 == 'L') goto S344;
  return m.FSM_HALT(c1);

S213:
  c0 = c1, c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S350;
  if (c1 == '-') goto S348;
  if (c1 == '+') goto S348;
  return m.FSM_HALT(c1);

S217:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S219:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S357;
  if (c1 == 'l') goto S359;
  if (c1 == 'U') goto S357;
  if (c1 == 'L') goto S359;
  return m.FSM_HALT(c1);

S225:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S217;
  if (c1 == 'f') goto S217;
  if (c1 == 'e') goto S213;
  if (c1 == 'L') goto S217;
  if (c1 == 'F') goto S217;
  if (c1 == 'E') goto S213;
  if ('0' <= c1 && c1 <= '9') goto S225;
  return m.FSM_HALT(c1);

S234:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '.') goto S363;
  return m.FSM_HALT(c1);

S236:
  m.FSM_TAKE(39);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S238:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S217;
  if (c1 == 'f') goto S217;
  if (c1 == 'e') goto S213;
  if (c1 == 'L') goto S217;
  if (c1 == 'F') goto S217;
  if (c1 == 'E') goto S213;
  if ('0' <= c1 && c1 <= '9') goto S238;
  if (c1 == '.') goto S200;
  return m.FSM_HALT(c1);

S248:
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'f') goto S365;
  if ('A' <= c1 && c1 <= 'F') goto S365;
  if ('0' <= c1 && c1 <= '9') goto S365;
  return m.FSM_HALT(c1);

S252:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S209;
  if (c1 == 'l') goto S219;
  if (c1 == 'f') goto S217;
  if (c1 == 'e') goto S213;
  if (c1 == 'U') goto S209;
  if (c1 == 'L') goto S219;
  if (c1 == 'F') goto S217;
  if (c1 == 'E') goto S213;
  if ('8' <= c1 && c1 <= '9') goto S238;
  if ('0' <= c1 && c1 <= '7') goto S252;
  if (c1 == '.') goto S200;
  return m.FSM_HALT(c1);

S265:
  m.FSM_TAKE(8);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S267:
  c0 = c1, c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S270;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S270;
  return m.FSM_HALT(c1);

S270:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S267;
  if (c1 == '\'') goto S265;
  if ('\v' <= c1) goto S270;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S270;
  return m.FSM_HALT(c1);

S275:
  m.FSM_TAKE(9);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S277:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\r') goto S374;
  if ('\0' <= c1) goto S279;
  return m.FSM_HALT(c1);

S279:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S277;
  if (c1 == '"') goto S275;
  if ('\v' <= c1) goto S279;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S279;
  return m.FSM_HALT(c1);

S284:
  m.FSM_TAKE(26);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S286:
  m.FSM_TAKE(28);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S377;
  return m.FSM_HALT(c1);

S289:
  m.FSM_TAKE(48);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S291:
  m.FSM_TAKE(56);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S293:
  m.FSM_TAKE(16);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S295:
  m.FSM_TAKE(17);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S297:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S299:
  m.FSM_TAKE(20);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S301:
  m.FSM_TAKE(22);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '*') goto S379;
  return m.FSM_HALT(c1);

S304:
  m.FSM_TAKE(24);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S306:
  m.FSM_TAKE(30);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S308:
  m.FSM_TAKE(32);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S381;
  return m.FSM_HALT(c1);

S311:
  m.FSM_TAKE(34);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S313:
  m.FSM_TAKE(41);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S315:
  m.FSM_TAKE(44);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S317:
  m.FSM_TAKE(50);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S319:
  m.FSM_TAKE(51);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S321:
  m.FSM_TAKE(53);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S323:
  m.FSM_TAKE(54);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S325:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S196;
  if ('\v' <= c1) goto S191;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S191;
  return m.FSM_HALT(c1);

S329:
  m.FSM_TAKE(2);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S331:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S331;
  if (c1 == '\n') goto S383;
  if ('\0' <= c1) goto S184;
  return m.FSM_HALT(c1);

S334:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '/') goto S387;
  if (c1 == '*') goto S389;
  if ('\0' <= c1) goto S337;
  return m.FSM_HALT(c1);

S337:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '*') goto S389;
  if ('\0' <= c1) goto S337;
  return m.FSM_HALT(c1);

S339:
  m.FSM_TAKE(4);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S341:
  c0 = c1, c1 = m.FSM_CHAR();
  if (m.FSM_META_BOL()) {
    m.FSM_TAKE(4, c1);
  }
  if (c1 == '\\') goto S196;
  if ('\0' <= c1) goto S191;
  return m.FSM_HALT(c1);

S344:
  m.FSM_TAKE(7);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S357;
  if (c1 == 'L') goto S357;
  return m.FSM_HALT(c1);

S348:
  c0 = c1, c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S350;
  return m.FSM_HALT(c1);

S350:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S217;
  if (c1 == 'f') goto S217;
  if (c1 == 'L') goto S217;
  if (c1 == 'F') goto S217;
  if ('0' <= c1 && c1 <= '9') goto S350;
  return m.FSM_HALT(c1);

S357:
  m.FSM_TAKE(7);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S359:
  m.FSM_TAKE(7);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S357;
  if (c1 == 'U') goto S357;
  return m.FSM_HALT(c1);

S363:
  m.FSM_TAKE(38);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S365:
  m.FSM_TAKE(7);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S209;
  if (c1 == 'l') goto S392;
  if ('a' <= c1 && c1 <= 'f') goto S365;
  if (c1 == 'U') goto S209;
  if (c1 == 'L') goto S392;
  if ('A' <= c1 && c1 <= 'F') goto S365;
  if ('0' <= c1 && c1 <= '9') goto S365;
  return m.FSM_HALT(c1);

S374:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S277;
  if (c1 == '"') goto S275;
  if ('\0' <= c1) goto S279;
  return m.FSM_HALT(c1);

S377:
  m.FSM_TAKE(27);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S379:
  m.FSM_TAKE(21);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S381:
  m.FSM_TAKE(31);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S383:
  m.FSM_TAKE(2);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S331;
  if (c1 == '\n') goto S329;
  if ('\0' <= c1) goto S184;
  return m.FSM_HALT(c1);

S387:
  m.FSM_TAKE(3);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S389:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '/') goto S387;
  if (c1 == '*') goto S389;
  if ('\0' <= c1) goto S337;
  return m.FSM_HALT(c1);

S392:
  m.FSM_TAKE(7);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S357;
  if (c1 == 'l') goto S359;
  if (c1 == 'U') goto S357;
  if (c1 == 'L') goto S359;
  return m.FSM_HALT(c1);
}

