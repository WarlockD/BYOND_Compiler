// RLex.cpp generated by reflex 1.4.3 from lexer.l

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_header_file         "RLex.h"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_outfile             "RLex.cpp"
#define REFLEX_OPTION_token_type          Token

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top{ user code %}                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 3 "lexer.l"

#include "util.hpp"
#include "Lex.hpp"



////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class Lexer : public reflex::AbstractLexer<reflex::Matcher> {
#line 10 "lexer.l"


	std::stack<string_t> _include_stack;

  Location get_location() {
	return Location(lineno(), columno());
  }


 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Lexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
#line 20 "lexer.l"



  }
  static const int INITIAL = 0;
  virtual Token lex();
  Token lex(
      const reflex::Input& input,
      std::ostream        *os = NULL)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "lexer.l"
// C/C++ tokenizer (plain, no Unicode)

#line 24 "lexer.l"
//%option flex
//%option nodefault
#line 29 "lexer.l"
/* may add %option unicode before the %include to match unicode identifiers */

#line 31 "lexer.l"
// %include "cdefs.l" // That is the definisions below

#line 33 "lexer.l"
// Requires RE/flex matcher or a Perl/ECMA matcher that supports lazy quants


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

extern void reflex_code_INITIAL(reflex::Matcher&);

Token Lexer::lex()
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
#line 57 "lexer.l"
//{WHITESPACE}
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
#line 76 "lexer.l"
{
    if (_include_stack.size() == 0)
    {
       terminate();
    } else {
         fclose(in());                   // close current input in() (a FILE*)
    	_include_stack.pop();
        pop_matcher();                  // delete current matcher, pop matcher
        }
    }

            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 57: (?:(?:\Q//\E)(?:[^\x0a]|\\\n)*\n)
#line 57 "lexer.l"
            break;
          case 2: // rule at line 58: (?:(?:\Q/*\E)(?:.|\n)*?(?:\Q*/\E))
#line 58 "lexer.l"
            break;
          case 3: // rule at line 60: (?:^[\x09\x20]*#(?:[^\x0a]|\\\r?\n)+)include\h*".*?"
#line 60 "lexer.l"
{
    if (_include_stack.size() > 99)
      exit(EXIT_FAILURE);           // max include depth exceeded
	  std::string_view file(text());
	  file.remove_prefix(file.find_first_of('"'));
	  file.remove_suffix(file.size()-file.find_last_of('"'));// get filename
	  _include_stack.push(file);
    FILE *fd = fopen(_include_stack.top().c_str(), "r");
    if (!fd)
      exit(EXIT_FAILURE);           // cannot open file
    push_matcher(new_matcher(fd));  // push current matcher, use new matcher

    }



            break;
          case 4: // rule at line 90: (?:[A-Z_a-z][0-9A-Z_a-z]*)
#line 90 "lexer.l"
return Token(text(), Punc::Name, get_location());
            break;
          case 5: // rule at line 91: (?:\d*(?:\d|\.\d|\d\.)\d*(?:[Ee][\x2b\x2d]?\d+)?[FLfl]?)
#line 91 "lexer.l"
return Token(text(), Punc::Float, get_location()); //static_cast<float>(0),get_location());
            break;
          case 6: // rule at line 92: (?:(?:(?:0[0-7]+)|(?:0[Xx][0-9A-Fa-f]+)|(?:0|[1-9]\d*))(?:[Ll]{0,2}[Uu]?|[Uu][Ll]{0,2}))
#line 92 "lexer.l"
return Token(text(), Punc::Int, get_location()); ///static_cast<int>(0),get_location());
            break;
          case 7: // rule at line 93: (?:L?'(?:\\.|[^\x0a'\x5c])*')
#line 93 "lexer.l"
return Token(text(), Punc::Char, get_location());
            break;
          case 8: // rule at line 94: (?:L?"(?:\\.|\\\r?\n|[^\x0a"\x5c])*")
#line 94 "lexer.l"
return Token(text(), Punc::String, get_location());
            break;
          case 9: // rule at line 95: (?:\Q\t\E)
#line 95 "lexer.l"
return Token(Punc::Tab,get_location());
            break;
          case 10: // rule at line 96: (?:\Q\n\E)
#line 96 "lexer.l"
return Token(Punc::Newline,get_location());
            break;
          case 11: // rule at line 97: (?:\Q \E)
#line 97 "lexer.l"
return Token(Punc::Space,get_location());
            break;
          case 12: // rule at line 98: (?:\Q!\E)
#line 98 "lexer.l"
return Token(Punc::Not,get_location());
            break;
          case 13: // rule at line 99: (?:\Q!=\E)
#line 99 "lexer.l"
return Token(Punc::NotEq,get_location());
            break;
          case 14: // rule at line 100: (?:\Q"\E)
#line 100 "lexer.l"
return Token(Punc::DoubleQuote,get_location());
            break;
          case 15: // rule at line 101: (?:\Q#\E)
#line 101 "lexer.l"
return Token(Punc::Hash,get_location());
            break;
          case 16: // rule at line 102: (?:\Q##\E)
#line 102 "lexer.l"
return Token(Punc::TokenPaste,get_location());
            break;
          case 17: // rule at line 103: (?:\Q%\E)
#line 103 "lexer.l"
return Token(Punc::Mod,get_location());
            break;
          case 18: // rule at line 104: (?:\Q%=\E)
#line 104 "lexer.l"
return Token(Punc::ModAssign,get_location());
            break;
          case 19: // rule at line 105: (?:\Q&\E)
#line 105 "lexer.l"
return Token(Punc::BitAnd,get_location());
            break;
          case 20: // rule at line 106: (?:\Q&&\E)
#line 106 "lexer.l"
return Token(Punc::And,get_location());
            break;
          case 21: // rule at line 107: (?:\Q&=\E)
#line 107 "lexer.l"
return Token(Punc::BitAndAssign,get_location());
            break;
          case 22: // rule at line 108: (?:\Q'\E)
#line 108 "lexer.l"
return Token(Punc::SingleQuote,get_location());
            break;
          case 23: // rule at line 109: (?:\Q(\E)
#line 109 "lexer.l"
return Token(Punc::LParen,get_location());
            break;
          case 24: // rule at line 110: (?:\Q)\E)
#line 110 "lexer.l"
return Token(Punc::RParen,get_location());
            break;
          case 25: // rule at line 111: (?:\Q*\E)
#line 111 "lexer.l"
return Token(Punc::Mul,get_location());
            break;
          case 26: // rule at line 112: (?:\Q**\E)
#line 112 "lexer.l"
return Token(Punc::Pow,get_location());
            break;
          case 27: // rule at line 113: (?:\Q*=\E)
#line 113 "lexer.l"
return Token(Punc::MulAssign,get_location());
            break;
          case 28: // rule at line 114: (?:\Q+\E)
#line 114 "lexer.l"
return Token(Punc::Add,get_location());
            break;
          case 29: // rule at line 115: (?:\Q++\E)
#line 115 "lexer.l"
return Token(Punc::PlusPlus,get_location());
            break;
          case 30: // rule at line 116: (?:\Q+=\E)
#line 116 "lexer.l"
return Token(Punc::AddAssign,get_location());
            break;
          case 31: // rule at line 117: (?:\Q,\E)
#line 117 "lexer.l"
return Token(Punc::Comma,get_location());
            break;
          case 32: // rule at line 118: (?:\Q-\E)
#line 118 "lexer.l"
return Token(Punc::Sub,get_location());
            break;
          case 33: // rule at line 119: (?:\Q--\E)
#line 119 "lexer.l"
return Token(Punc::MinusMinus,get_location());
            break;
          case 34: // rule at line 120: (?:\Q-=\E)
#line 120 "lexer.l"
return Token(Punc::SubAssign,get_location());
            break;
          case 35: // rule at line 121: (?:\Q.\E)
#line 121 "lexer.l"
return Token(Punc::Dot,get_location());
            break;
          case 36: // rule at line 122: (?:\Q..\E)
#line 122 "lexer.l"
return Token(Punc::Super,get_location());
            break;
          case 37: // rule at line 123: (?:\Q...\E)
#line 123 "lexer.l"
return Token(Punc::Ellipsis,get_location());
            break;
          case 38: // rule at line 124: (?:\Q/\E)
#line 124 "lexer.l"
return Token(Punc::Slash,get_location());
            break;
          case 39: // rule at line 125: (?:\Q/*\E)
#line 125 "lexer.l"
return Token(Punc::BlockComment,get_location());
            break;
          case 40: // rule at line 126: (?:\Q//\E)
#line 126 "lexer.l"
return Token(Punc::LineComment,get_location());
            break;
          case 41: // rule at line 127: (?:\Q/=\E)
#line 127 "lexer.l"
return Token(Punc::DivAssign,get_location());
            break;
          case 42: // rule at line 128: (?:\Q:\E)
#line 128 "lexer.l"
return Token(Punc::Colon,get_location());//-> CloseColon;
            break;
          case 43: // rule at line 129: (?:\Q;\E)
#line 129 "lexer.l"
return Token(Punc::Semicolon,get_location());
            break;
          case 44: // rule at line 130: (?:\Q<\E)
#line 130 "lexer.l"
return Token(Punc::Less,get_location());
            break;
          case 45: // rule at line 131: (?:\Q<<\E)
#line 131 "lexer.l"
return Token(Punc::LShift,get_location());
            break;
          case 46: // rule at line 132: (?:\Q<<=\E)
#line 132 "lexer.l"
return Token(Punc::LShiftAssign,get_location());
            break;
          case 47: // rule at line 133: (?:\Q<=\E)
#line 133 "lexer.l"
return Token(Punc::LessEq,get_location());
            break;
          case 48: // rule at line 134: (?:\Q<>\E)
#line 134 "lexer.l"
return Token(Punc::LessGreater,get_location());
            break;
          case 49: // rule at line 135: (?:\Q=\E)
#line 135 "lexer.l"
return Token(Punc::Assign,get_location());
            break;
          case 50: // rule at line 136: (?:\Q==\E)
#line 136 "lexer.l"
return Token(Punc::Eq,get_location());
            break;
          case 51: // rule at line 137: (?:\Q>\E)
#line 137 "lexer.l"
return Token(Punc::Greater,get_location());
            break;
          case 52: // rule at line 138: (?:\Q>=\E)
#line 138 "lexer.l"
return Token(Punc::GreaterEq,get_location());
            break;
          case 53: // rule at line 139: (?:\Q>>\E)
#line 139 "lexer.l"
return Token(Punc::RShift,get_location());
            break;
          case 54: // rule at line 140: (?:\Q>>=\E)
#line 140 "lexer.l"
return Token(Punc::RShiftAssign,get_location());
            break;
          case 55: // rule at line 141: (?:\Q?\E)
#line 141 "lexer.l"
return Token(Punc::QuestionMark,get_location());
            break;
          case 56: // rule at line 142: (?:\Q?.\E)
#line 142 "lexer.l"
return Token(Punc::SafeDot,get_location());
            break;
          case 57: // rule at line 143: (?:\Q?:\E)
#line 143 "lexer.l"
return Token(Punc::SafeColon,get_location());
            break;
          case 58: // rule at line 144: (?:\Q[\E)
#line 144 "lexer.l"
return Token(Punc::LBracket,get_location());
            break;
          case 59: // rule at line 145: (?:\Q]\E)
#line 145 "lexer.l"
return Token(Punc::RBracket,get_location());
            break;
          case 60: // rule at line 146: (?:\Q^\E)
#line 146 "lexer.l"
return Token(Punc::BitXor,get_location());
            break;
          case 61: // rule at line 147: (?:\Q^=\E)
#line 147 "lexer.l"
return Token(Punc::BitXorAssign,get_location());
            break;
          case 62: // rule at line 148: (?:\Q{\E)
#line 148 "lexer.l"
return Token(Punc::LBrace,get_location());
            break;
          case 63: // rule at line 149: (?:\Q{"\E)
#line 149 "lexer.l"
return Token(Punc:: BlockString,get_location());
            break;
          case 64: // rule at line 150: (?:\Q|\E)
#line 150 "lexer.l"
return Token(Punc::BitOr,get_location());
            break;
          case 65: // rule at line 151: (?:\Q|=\E)
#line 151 "lexer.l"
return Token(Punc::BitOrAssign,get_location());
            break;
          case 66: // rule at line 152: (?:\Q||\E)
#line 152 "lexer.l"
return Token(Punc::Or,get_location());
            break;
          case 67: // rule at line 153: (?:\Q}\E)
#line 153 "lexer.l"
return Token(Punc::RBrace,get_location());
            break;
          case 68: // rule at line 154: (?:\Q~\E)
#line 154 "lexer.l"
return Token(Punc::BitNot,get_location());
            break;
          case 69: // rule at line 155: (?:\Q~!\E)
#line 155 "lexer.l"
return Token(Punc::NotEquiv,get_location());
            break;
          case 70: // rule at line 156: (?:\Q~=\E)
#line 156 "lexer.l"
return Token(Punc::Equiv,get_location());

            break;
          case 71: // rule at line 158: .
#line 158 "lexer.l"

        return Token(Punc::Null,get_location());  //printf("*** ERROR '%s' at line %d\n", yytext, yylineno);

            break;
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 162 "lexer.l"


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-label"
#endif

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '~') goto S171;
  if (c1 == '}') goto S169;
  if (c1 == '|') goto S165;
  if (c1 == '{') goto S162;
  if ('a' <= c1 && c1 <= 'z') goto S49;
  if (c1 == '^') goto S159;
  if (c1 == ']') goto S157;
  if (c1 == '\\') goto S98;
  if (c1 == '[') goto S155;
  if (c1 == 'L') goto S182;
  if ('A' <= c1 && c1 <= '_') goto S49;
  if (c1 == '?') goto S151;
  if (c1 == '>') goto S147;
  if (c1 == '=') goto S144;
  if (c1 == '<') goto S139;
  if (c1 == ';') goto S137;
  if (c1 == ':') goto S135;
  if ('1' <= c1 && c1 <= '9') goto S55;
  if (c1 == '0') goto S71;
  if (c1 == '/') goto S38;
  if (c1 == '.') goto S67;
  if (c1 == '-') goto S131;
  if (c1 == ',') goto S129;
  if (c1 == '+') goto S125;
  if (c1 == '*') goto S121;
  if (c1 == ')') goto S119;
  if (c1 == '(') goto S117;
  if (c1 == '\'') goto S86;
  if (c1 == '&') goto S113;
  if (c1 == '%') goto S110;
  if (c1 == '#') goto S43;
  if (c1 == '"') goto S92;
  if (c1 == '!') goto S107;
  if (c1 == ' ') goto S102;
  if ('\v' <= c1) goto S175;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (c1 == '\t') goto S177;
  if ('\0' <= c1 && c1 <= '\b') goto S175;
  return m.FSM_HALT(c1);

S38:
  m.FSM_TAKE(38);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S197;
  if (c1 == '/') goto S190;
  if (c1 == '*') goto S194;
  return m.FSM_HALT(c1);

S43:
  m.FSM_TAKE(15);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S210;
  if (c1 == '#') goto S199;
  if ('\v' <= c1) goto S205;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S205;
  return m.FSM_HALT(c1);

S49:
  m.FSM_TAKE(4);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S49;
  if (c1 == '_') goto S49;
  if ('A' <= c1 && c1 <= 'Z') goto S49;
  if ('0' <= c1 && c1 <= '9') goto S49;
  return m.FSM_HALT(c1);

S55:
  m.FSM_TAKE(5);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S223;
  if (c1 == 'l') goto S233;
  if (c1 == 'f') goto S231;
  if (c1 == 'e') goto S227;
  if (c1 == 'U') goto S223;
  if (c1 == 'L') goto S233;
  if (c1 == 'F') goto S231;
  if (c1 == 'E') goto S227;
  if ('0' <= c1 && c1 <= '9') goto S55;
  if (c1 == '.') goto S214;
  return m.FSM_HALT(c1);

S67:
  m.FSM_TAKE(35);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S239;
  if (c1 == '.') goto S248;
  return m.FSM_HALT(c1);

S71:
  m.FSM_TAKE(5);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'x') goto S261;
  if (c1 == 'u') goto S223;
  if (c1 == 'l') goto S233;
  if (c1 == 'f') goto S231;
  if (c1 == 'e') goto S227;
  if (c1 == 'X') goto S261;
  if (c1 == 'U') goto S223;
  if (c1 == 'L') goto S233;
  if (c1 == 'F') goto S231;
  if (c1 == 'E') goto S227;
  if ('8' <= c1 && c1 <= '9') goto S251;
  if ('0' <= c1 && c1 <= '7') goto S265;
  if (c1 == '.') goto S214;
  return m.FSM_HALT(c1);

S86:
  m.FSM_TAKE(22);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S280;
  if (c1 == '\'') goto S278;
  if ('\v' <= c1) goto S283;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S283;
  return m.FSM_HALT(c1);

S92:
  m.FSM_TAKE(14);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S290;
  if (c1 == '"') goto S288;
  if ('\v' <= c1) goto S292;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S292;
  return m.FSM_HALT(c1);

S98:
  m.FSM_TAKE(71);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 't') goto S297;
  if (c1 == 'n') goto S299;
  return m.FSM_HALT(c1);

S102:
  m.FSM_TAKE(11);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '#') goto S301;
  if (c1 == ' ') goto S305;
  if (c1 == '\t') goto S305;
  return m.FSM_HALT(c1);

S107:
  m.FSM_TAKE(12);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S309;
  return m.FSM_HALT(c1);

S110:
  m.FSM_TAKE(17);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S311;
  return m.FSM_HALT(c1);

S113:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S315;
  if (c1 == '&') goto S313;
  return m.FSM_HALT(c1);

S117:
  m.FSM_TAKE(23);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S119:
  m.FSM_TAKE(24);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S121:
  m.FSM_TAKE(25);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S319;
  if (c1 == '*') goto S317;
  return m.FSM_HALT(c1);

S125:
  m.FSM_TAKE(28);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S323;
  if (c1 == '+') goto S321;
  return m.FSM_HALT(c1);

S129:
  m.FSM_TAKE(31);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S131:
  m.FSM_TAKE(32);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S327;
  if (c1 == '-') goto S325;
  return m.FSM_HALT(c1);

S135:
  m.FSM_TAKE(42);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S137:
  m.FSM_TAKE(43);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S139:
  m.FSM_TAKE(44);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '>') goto S334;
  if (c1 == '=') goto S332;
  if (c1 == '<') goto S329;
  return m.FSM_HALT(c1);

S144:
  m.FSM_TAKE(49);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S336;
  return m.FSM_HALT(c1);

S147:
  m.FSM_TAKE(51);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '>') goto S340;
  if (c1 == '=') goto S338;
  return m.FSM_HALT(c1);

S151:
  m.FSM_TAKE(55);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ':') goto S345;
  if (c1 == '.') goto S343;
  return m.FSM_HALT(c1);

S155:
  m.FSM_TAKE(58);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S157:
  m.FSM_TAKE(59);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S159:
  m.FSM_TAKE(60);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S347;
  return m.FSM_HALT(c1);

S162:
  m.FSM_TAKE(62);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '"') goto S349;
  return m.FSM_HALT(c1);

S165:
  m.FSM_TAKE(64);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '|') goto S353;
  if (c1 == '=') goto S351;
  return m.FSM_HALT(c1);

S169:
  m.FSM_TAKE(67);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S171:
  m.FSM_TAKE(68);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S357;
  if (c1 == '!') goto S355;
  return m.FSM_HALT(c1);

S175:
  m.FSM_TAKE(71);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S177:
  m.FSM_TAKE(71);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '#') goto S301;
  if (c1 == ' ') goto S305;
  if (c1 == '\t') goto S305;
  return m.FSM_HALT(c1);

S182:
  m.FSM_TAKE(4);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S49;
  if (c1 == '_') goto S49;
  if ('A' <= c1 && c1 <= 'Z') goto S49;
  if ('0' <= c1 && c1 <= '9') goto S49;
  if (c1 == '\'') goto S283;
  if (c1 == '"') goto S292;
  return m.FSM_HALT(c1);

S190:
  m.FSM_TAKE(40);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S364;
  if (c1 == '\n') goto S359;
  if ('\0' <= c1) goto S361;
  return m.FSM_HALT(c1);

S194:
  m.FSM_TAKE(39);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '*') goto S367;
  if ('\0' <= c1) goto S370;
  return m.FSM_HALT(c1);

S197:
  m.FSM_TAKE(41);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S199:
  m.FSM_TAKE(16);
  c0 = c1, c1 = m.FSM_CHAR();
  if (m.FSM_META_BOL()) {
  }
  if (c1 == '\\') goto S210;
  if ('\v' <= c1) goto S205;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S205;
  return m.FSM_HALT(c1);

S205:
  c0 = c1, c1 = m.FSM_CHAR();
  if (m.FSM_META_BOL()) {
  }
  if (c1 == '\\') goto S210;
  if ('\v' <= c1) goto S205;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S205;
  return m.FSM_HALT(c1);

S210:
  c0 = c1, c1 = m.FSM_CHAR();
  if (m.FSM_META_BOL()) {
  }
  if (c1 == '\\') goto S210;
  if (c1 == '\r') goto S374;
  if ('\0' <= c1) goto S205;
  return m.FSM_HALT(c1);

S214:
  m.FSM_TAKE(5);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S231;
  if (c1 == 'f') goto S231;
  if (c1 == 'e') goto S227;
  if (c1 == 'L') goto S231;
  if (c1 == 'F') goto S231;
  if (c1 == 'E') goto S227;
  if ('0' <= c1 && c1 <= '9') goto S239;
  return m.FSM_HALT(c1);

S223:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S377;
  if (c1 == 'L') goto S377;
  return m.FSM_HALT(c1);

S227:
  c0 = c1, c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S383;
  if (c1 == '-') goto S381;
  if (c1 == '+') goto S381;
  return m.FSM_HALT(c1);

S231:
  m.FSM_TAKE(5);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S233:
  m.FSM_TAKE(5);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S390;
  if (c1 == 'l') goto S392;
  if (c1 == 'U') goto S390;
  if (c1 == 'L') goto S392;
  return m.FSM_HALT(c1);

S239:
  m.FSM_TAKE(5);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S231;
  if (c1 == 'f') goto S231;
  if (c1 == 'e') goto S227;
  if (c1 == 'L') goto S231;
  if (c1 == 'F') goto S231;
  if (c1 == 'E') goto S227;
  if ('0' <= c1 && c1 <= '9') goto S239;
  return m.FSM_HALT(c1);

S248:
  m.FSM_TAKE(36);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '.') goto S396;
  return m.FSM_HALT(c1);

S251:
  m.FSM_TAKE(5);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S231;
  if (c1 == 'f') goto S231;
  if (c1 == 'e') goto S227;
  if (c1 == 'L') goto S231;
  if (c1 == 'F') goto S231;
  if (c1 == 'E') goto S227;
  if ('0' <= c1 && c1 <= '9') goto S251;
  if (c1 == '.') goto S214;
  return m.FSM_HALT(c1);

S261:
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'f') goto S398;
  if ('A' <= c1 && c1 <= 'F') goto S398;
  if ('0' <= c1 && c1 <= '9') goto S398;
  return m.FSM_HALT(c1);

S265:
  m.FSM_TAKE(5);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S223;
  if (c1 == 'l') goto S233;
  if (c1 == 'f') goto S231;
  if (c1 == 'e') goto S227;
  if (c1 == 'U') goto S223;
  if (c1 == 'L') goto S233;
  if (c1 == 'F') goto S231;
  if (c1 == 'E') goto S227;
  if ('8' <= c1 && c1 <= '9') goto S251;
  if ('0' <= c1 && c1 <= '7') goto S265;
  if (c1 == '.') goto S214;
  return m.FSM_HALT(c1);

S278:
  m.FSM_TAKE(7);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S280:
  c0 = c1, c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S283;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S283;
  return m.FSM_HALT(c1);

S283:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S280;
  if (c1 == '\'') goto S278;
  if ('\v' <= c1) goto S283;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S283;
  return m.FSM_HALT(c1);

S288:
  m.FSM_TAKE(8);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S290:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\r') goto S407;
  if ('\0' <= c1) goto S292;
  return m.FSM_HALT(c1);

S292:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S290;
  if (c1 == '"') goto S288;
  if ('\v' <= c1) goto S292;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S292;
  return m.FSM_HALT(c1);

S297:
  m.FSM_TAKE(9);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S299:
  m.FSM_TAKE(10);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S301:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S210;
  if ('\v' <= c1) goto S205;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S205;
  return m.FSM_HALT(c1);

S305:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '#') goto S301;
  if (c1 == ' ') goto S305;
  if (c1 == '\t') goto S305;
  return m.FSM_HALT(c1);

S309:
  m.FSM_TAKE(13);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S311:
  m.FSM_TAKE(18);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S313:
  m.FSM_TAKE(20);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S315:
  m.FSM_TAKE(21);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S317:
  m.FSM_TAKE(26);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S319:
  m.FSM_TAKE(27);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S321:
  m.FSM_TAKE(29);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S323:
  m.FSM_TAKE(30);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S325:
  m.FSM_TAKE(33);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S327:
  m.FSM_TAKE(34);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S329:
  m.FSM_TAKE(45);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S410;
  return m.FSM_HALT(c1);

S332:
  m.FSM_TAKE(47);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S334:
  m.FSM_TAKE(48);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S336:
  m.FSM_TAKE(50);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S338:
  m.FSM_TAKE(52);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S340:
  m.FSM_TAKE(53);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '=') goto S412;
  return m.FSM_HALT(c1);

S343:
  m.FSM_TAKE(56);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S345:
  m.FSM_TAKE(57);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S347:
  m.FSM_TAKE(61);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S349:
  m.FSM_TAKE(63);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S351:
  m.FSM_TAKE(65);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S353:
  m.FSM_TAKE(66);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S355:
  m.FSM_TAKE(69);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S357:
  m.FSM_TAKE(70);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S359:
  m.FSM_TAKE(1);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S361:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S364;
  if (c1 == '\n') goto S359;
  if ('\0' <= c1) goto S361;
  return m.FSM_HALT(c1);

S364:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S364;
  if (c1 == '\n') goto S414;
  if ('\0' <= c1) goto S361;
  return m.FSM_HALT(c1);

S367:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '/') goto S418;
  if (c1 == '*') goto S420;
  if ('\0' <= c1) goto S370;
  return m.FSM_HALT(c1);

S370:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '*') goto S420;
  if ('\0' <= c1) goto S370;
  return m.FSM_HALT(c1);

S372:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'i') goto S423;
  return m.FSM_HALT(c1);

S374:
  c0 = c1, c1 = m.FSM_CHAR();
  if (m.FSM_META_BOL()) {
  }
  if (c1 == '\\') goto S210;
  if ('\0' <= c1) goto S205;
  return m.FSM_HALT(c1);

S377:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S390;
  if (c1 == 'L') goto S390;
  return m.FSM_HALT(c1);

S381:
  c0 = c1, c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S383;
  return m.FSM_HALT(c1);

S383:
  m.FSM_TAKE(5);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S231;
  if (c1 == 'f') goto S231;
  if (c1 == 'L') goto S231;
  if (c1 == 'F') goto S231;
  if ('0' <= c1 && c1 <= '9') goto S383;
  return m.FSM_HALT(c1);

S390:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S392:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S390;
  if (c1 == 'U') goto S390;
  return m.FSM_HALT(c1);

S396:
  m.FSM_TAKE(37);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S398:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S223;
  if (c1 == 'l') goto S425;
  if ('a' <= c1 && c1 <= 'f') goto S398;
  if (c1 == 'U') goto S223;
  if (c1 == 'L') goto S425;
  if ('A' <= c1 && c1 <= 'F') goto S398;
  if ('0' <= c1 && c1 <= '9') goto S398;
  return m.FSM_HALT(c1);

S407:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S290;
  if (c1 == '"') goto S288;
  if ('\0' <= c1) goto S292;
  return m.FSM_HALT(c1);

S410:
  m.FSM_TAKE(46);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S412:
  m.FSM_TAKE(54);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S414:
  m.FSM_TAKE(1);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S364;
  if (c1 == '\n') goto S359;
  if ('\0' <= c1) goto S361;
  return m.FSM_HALT(c1);

S418:
  m.FSM_TAKE(2);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S420:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '/') goto S418;
  if (c1 == '*') goto S420;
  if ('\0' <= c1) goto S370;
  return m.FSM_HALT(c1);

S423:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S431;
  return m.FSM_HALT(c1);

S425:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S390;
  if (c1 == 'l') goto S392;
  if (c1 == 'U') goto S390;
  if (c1 == 'L') goto S392;
  return m.FSM_HALT(c1);

S431:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'c') goto S433;
  return m.FSM_HALT(c1);

S433:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S435;
  return m.FSM_HALT(c1);

S435:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S437;
  return m.FSM_HALT(c1);

S437:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'd') goto S439;
  return m.FSM_HALT(c1);

S439:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S441;
  return m.FSM_HALT(c1);

S441:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '"') goto S445;
  if (c1 == ' ') goto S441;
  if (c1 == '\t') goto S441;
  return m.FSM_HALT(c1);

S445:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '"') goto S449;
  if ('\v' <= c1) goto S451;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S451;
  return m.FSM_HALT(c1);

S449:
  m.FSM_TAKE(3);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S451:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '"') goto S449;
  if ('\v' <= c1) goto S451;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S451;
  return m.FSM_HALT(c1);
}

