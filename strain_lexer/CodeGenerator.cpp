/**********************************************************
 * File: CodeGenerator.cpp
 * Author: Keith Schwarz (htiek@cs.stanford.edu)
 *
 * Implementation of the CodeGenerator interface.
 */

#include "CodeGenerator.hh"
#include "Automaton.hh"
#include <iostream>
#include <vector>
#include <string>
#include <stdexcept>
#include <iterator>
#include <fstream>
#include <cstdlib>
#include <queue>
using namespace std;

/* Constructs a table of states from an automaton so that we can use
 * integer identifiers to refer to them.
 */
void BuildStateTable(RegexpAutomaton automaton,
	map<MachineState*, int>& stateTable) {
	/* Associate NULL with -1. */
	stateTable[NULL] = -1;

	/* Standard BFS. */
	queue<MachineState*> toVisit;
	toVisit.push(automaton.start);

	while (!toVisit.empty()) {
		MachineState* curr = toVisit.front();
		toVisit.pop();

		/* If we already labelled this state, don't label it again! */
		if (stateTable.find(curr) != stateTable.end())
			continue;

		/* We want to use the next unused number as the value for this
		 * state.  Since we used -1 for NULL, the next number is the number
		 * of entries already recorded, minus one.
		 */
		int nextNum = int(stateTable.size() - 1);
		stateTable[curr] = nextNum;

		/* Explore outward. */
		for (multimap<char, MachineState*>::iterator itr =
			curr->transitions.begin();
			itr != curr->transitions.end(); ++itr)
			toVisit.push(itr->second);
	}
}

/* Writes out the C++ file header. */
void WriteHeader(ostream& out, size_t numStates,
	const map<string, string>& tokens) {
	out << "/* Lexer generated by strain. */" << endl;
	out << "#ifndef Lexer_Included" << endl;
	out << "#define Lexer_Included" << endl;
	out << endl;
	out << "#include <string>" << endl;
	out << "#include <istream>" << endl;
	out << "#include <utility>" << endl;
	out << endl;
	out << "namespace strain {" << endl;
	out << "  /* An object representing some Lexeme.  This object can take on any" << endl;
	out << "   * value, and can be downcasted using the lexeme_cast function." << endl;
	out << "   */" << endl;
	out << "  class Lexeme {" << endl;
	out << "  public:" << endl;
	out << "    /* Default constructor for convenience. */" << endl;
	out << "    Lexeme() {" << endl;
	out << "      impl = new HolderImpl<int>(0);" << endl;
	out << "    }" << endl;
	out << endl;
	out << "    /**" << endl;
	out << "     * Copy and destruction functions." << endl;
	out << "     */" << endl;
	out << "    Lexeme(const Lexeme&);" << endl;
	out << "    Lexeme& operator= (const Lexeme&);" << endl;
	out << "    ~Lexeme();" << endl;
	out << endl;
	out << "    /**" << endl;
	out << "     * const T& lexeme_cast(const Lexeme& lex);" << endl;
	out << "     * ----------------------------------------------------" << endl;
	out << "     * Downcasts the Lexeme to its stored object, throwing" << endl;
	out << "     * a bad_cast exception if the cast fails.  T must be" << endl;
	out << "     * const." << endl;
	out << "     */" << endl;
	out << "    template <typename T> friend const T& lexeme_cast(const Lexeme& lex) {" << endl;
	out << "      return static_cast<T&>(dynamic_cast<HolderImpl<const T>&>(*lex.impl).value);" << endl;
	out << "    }" << endl;
	out << endl;
	out << "  private:" << endl;
	out << "    class HolderBase {" << endl;
	out << "    public: " << endl;
	out << "      virtual ~HolderBase() {}" << endl;
	out << "      virtual HolderBase* clone() const = 0;" << endl;
	out << "    };" << endl;
	out << endl;
	out << "    template <typename T> class HolderImpl: public HolderBase {" << endl;
	out << "    public:" << endl;
	out << "      HolderImpl(const T& value) : value(value) {}" << endl;
	out << "      virtual HolderImpl* clone() const {" << endl;
	out << "        return new HolderImpl(*this);" << endl;
	out << "      }" << endl;
	out << "      T value;" << endl;
	out << "    };" << endl;
	out << endl;
	out << "    friend class Lexer;" << endl;
	out << endl;
	out << "    /* Private constructor invoked by Lexer code. */" << endl;
	out << "    template <typename T> Lexeme(T value) {" << endl;
	out << "      impl = new HolderImpl<const T>(value);" << endl;
	out << "    }" << endl;
	out << endl;
	out << "    HolderBase* impl;" << endl;
	out << "  };" << endl;
	out << endl;
	out << "  class Lexer {" << endl;
	out << "  public:" << endl;
	out << "    /**" << endl;
	out << "     * Type: LexemeType" << endl;
	out << "     * ----------------------------------------------------" << endl;
	out << "     * An enumerated type corresponding to the types of each" << endl;
	out << "     * Lexeme, along with the special type None indicating" << endl;
	out << "     * that a call to next() produced no lexeme." << endl;
	out << "     */" << endl;
	out << "    enum LexemeType {" << endl;

	for (map<string, string>::const_iterator itr = tokens.begin(); itr != tokens.end(); ++itr)
		out << "      " << "Lexeme_" << itr->first << "," << endl;
	out << "      None" << endl;
	out << "    };" << endl;
	out << endl;

	out << "    /**" << endl;
	out << "     * Lexer(std::istream& input);" << endl;
	out << "     * ----------------------------------------------------" << endl;
	out << "     * Constructs a new Lexer that parses input from the" << endl;
	out << "     * specified stream." << endl;
	out << "     */" << endl;
	out << "    explicit Lexer(std::istream& input) : mInput(input) {" << endl;
	out << "      mIsStaged = false;" << endl;
	out << "    }" << endl;
	out << endl;
	out << "    /**" << endl;
	out << "     * pair<LexemeType, Lexeme> next();" << endl;
	out << "     * ----------------------------------------------------" << endl;
	out << "     * Runs the Lexer until another token is produced," << endl;
	out << "     * returning the pair (LexemeType, Lexeme).  If an" << endl;
	out << "     * error occurs, throws a runtime_error.  If no lexeme" << endl;
	out << "     * is produced, the LexemeType will be None." << endl;
	out << "     */" << endl;
	out << "    std::pair<LexemeType, Lexeme> next();" << endl;
	out << endl;
	out << "    /**" << endl;
	out << "     * pair<LexemeType, Lexeme> front();" << endl;
	out << "     * ----------------------------------------------------" << endl;
	out << "     * Returns, but does not consume, the next token in the" << endl;
	out << "     * sequence, throwing a runtime_error if an error occurs" << endl;
	out << "     * an producing a Lexeme of type None if no more tokens" << endl;
	out << "     * remain." << endl;
	out << "     *" << endl;
	out << "     * This function is not const because the semantic actions" << endl;
	out << "     * associated with the produced token may have side-effects." << endl;
	out << "     */" << endl;
	out << "    std::pair<LexemeType, Lexeme> front();" << endl;
	out << endl;
	out << "  private:" << endl;
	out << "    std::istream& mInput;" << endl;
	out << "    bool mIsStaged; // Whether a token is staged." << endl;
	out << "    std::pair<LexemeType, Lexeme> mStagedToken;" << endl;
	out << endl;
	out << "    bool processLexeme(int state, const std::string& lexeme," << endl;
	out << "                       std::pair<LexemeType, Lexeme>& out);" << endl;
	out << "  };" << endl;
	out << "}" << endl;
	out << endl;
	out << "#endif" << endl;
}

/* Writes out the top of the .cpp file. */
void WriteCppFileHeader(ostream& out, const string& prototypes) {
	out << "#include \"Lexer.hh\"" << endl;
	out << "#include <stdexcept>" << endl;
	out << "#include <limits>" << endl;
	out << "using namespace std;" << endl;
	out << endl;
	out << "/* START User-defined preamble code. */" << endl;
	out << prototypes << endl;
	out << "/* END User-defined preamble code. */" << endl;
	out << endl;
}

/* Writes out the transition tables. */
void WriteTransitionTables(ostream& out,
	const map<MachineState*, int>& stateTable,
	const vector<MachineState*>& inverseStateTable) {
	out << "/* State transition tables. */" << endl;
	out << "static const int kTransitionTable[" << inverseStateTable.size()
		<< "][128] = {" << endl;
	for (size_t i = 0; i < inverseStateTable.size(); ++i) {
		out << "  {" << endl;
		for (int ch = 0; ch < 128; ++ch) {
			multimap<char, MachineState*>::iterator itr =
				inverseStateTable[i]->transitions.find(char(ch));
			if (itr == inverseStateTable[i]->transitions.end())
				out << "-1, ";
			else
				out << stateTable.find(itr->second)->second << ", ";

			if (ch % 16 == 15)
				out << endl;
		}
		out << "  }," << endl;
	}

	out << "};" << endl << endl;
}

void WriteTerminalTables(ostream& out,
	const vector<MachineState*>& states) {
	out << "static const int kTerminalTable[" << states.size()
		<< "] = {" << endl;

	for (size_t i = 0; i < states.size(); ++i) {
		out << states[i]->terminalNumber << ", ";
		if (i % 16 == 15)
			out << endl;
	}
	out << "};" << endl;
	out << endl;
}

/* Writes out the typedefs for each token.  These are put into namespace strain
 * and have the form TypeOf[lexemename].  The idea is that we will write out
 * these typedefs and then cast each of the arguments to RETURN to have type
 * const TypeOf[lexemename].  This ensures that the types work and that the
 * types used in lexeme_cast match the expected types.
 */
void WriteTokenTypedefs(ostream& out,
	const map<string, string>& tokens) {
	out << "/* Typedefs to improve type-checking. */" << endl;
	out << "namespace strain {" << endl;

	for (map<string, string>::const_iterator itr = tokens.begin();
		itr != tokens.end(); ++itr)
		out << "  typedef " << itr->second << " TypeOf" << itr->first << ";" << endl;

	out << "}" << endl;
	out << endl;
}

/* Writes out the processLexeme function, which processes semantic actions. */
void WriteSemanticActions(ostream& out, const vector<pair<string, string> >& regexps) {
	out << "/* Function responsible for doing semantic actions. */" << endl;
	out << "bool strain::Lexer::processLexeme(int terminalState, const string& TOKEN," << endl;
	out << "                                  pair<LexemeType, Lexeme>& out) {" << endl;
	out << "  /* Set up the RETURN macro. */" << endl;
	out << "  #define RETURN(token, value)                                        \\" << endl;
	out << "    do {                                                              \\" << endl;
	out << "       out.first = strain::Lexer::Lexeme_##token;                     \\" << endl;
	out << "       out.second = static_cast<const strain::TypeOf##token>(value);  \\" << endl;
	out << "       return true;                                                   \\" << endl;
	out << "    } while(0)" << endl;
	out << endl;
	out << "  /* Based on the type of the terminal state, perform the appropriate" << endl;
	out << "   * action." << endl;
	out << "   */" << endl;
	out << "  switch (terminalState) {" << endl;
	for (size_t i = 0; i < regexps.size(); ++i) {
		out << "    case " << i << ": " << endl;
		out << "    {" << endl;
		out << regexps[i].second << endl;
		out << "    }" << endl;
		out << "    break;" << endl;
	}
	out << "    /* If it's something else, we're in trouble. */" << endl;
	out << "    default:" << endl;
	out << "      throw runtime_error(\"Undefined terminal state.\");" << endl;
	out << "  }" << endl;
	out << endl;
	out << "  /* If we're here, the action didn't RETURN anything.  Signal that by" << endl;
	out << "   * returning false." << endl;
	out << "   */" << endl;
	out << "  return false;" << endl;
	out << "}" << endl;
	out << endl;
}

/* Actually writes out the function to do the lexing. */
void WriteLexerFunction(ostream& out) {
	out << "pair<strain::Lexer::LexemeType, strain::Lexeme> strain::Lexer::next() {" << endl;
	out << "  /* If something isn't already staged, stage it. */" << endl;
	out << "  if (!mIsStaged)" << endl;
	out << "    (void)front();" << endl;
	out << "  /* Unstage the token. */" << endl;
	out << "  mIsStaged = false;" << endl;
	out << "  return mStagedToken;" << endl;
	out << "}" << endl;
	out << endl;
	out << "pair<strain::Lexer::LexemeType, strain::Lexeme> strain::Lexer::front() {" << endl;
	out << "  /* If something is already staged, just return that. */" << endl;
	out << "  if (mIsStaged) return mStagedToken;" << endl;
	out << endl;
	out << "  /* If the stream is broken, return EOF. */" << endl;
	out << "  if (!mInput) return mStagedToken = make_pair(Lexer::None, Lexeme());" << endl;
	out << endl;
	out << "  char ch;" << endl;
	out << "  int state = 0;" << endl;
	out << "  string currToken;" << endl;
	out << endl;
	out << "  while (mInput.get(ch)) {" << endl;
	out << "    /* Filter out non-ASCII characters. */" << endl;
	out << "    if (int(ch) < 0 || int(ch) > 127)" << endl;
	out << "      throw runtime_error(\"Non-ASCII character.\");" << endl;
	out << endl;
	out << "    /* Follow the transition and see where it ends up. */" << endl;
	out << "    int nextState = kTransitionTable[state][ch];" << endl;
	out << "    if (nextState == -1) {" << endl;
	out << "      int thisState = state;" << endl;
	out << "      string thisToken = currToken;" << endl;
	out << endl;
	out << "      state = 0;" << endl;
	out << "      currToken.clear();" << endl;
	out << endl;
	out << "      mInput.unget();" << endl;
	out << endl;
	out << "      /* Process the token, possibly returning. */" << endl;
	out << "      if (processLexeme(kTerminalTable[thisState], thisToken, mStagedToken)) {" << endl;
	out << "         mIsStaged = true;" << endl;
	out << "         return mStagedToken;" << endl;
	out << "      }" << endl;
	out << "   } else {" << endl;
	out << "     currToken += ch;" << endl;
	out << "     state = nextState;" << endl;
	out << "    }" << endl;
	out << "  }" << endl;
	out << endl;
	out << "  /* If we made it out here, it means that a token stretched to the end of" << endl;
	out << "   * the file.  Process the leftovers." << endl;
	out << "   */" << endl;
	out << "  mStagedToken = make_pair(Lexer::None, Lexeme());" << endl;
	out << "  if (processLexeme(kTerminalTable[state], currToken, mStagedToken))" << endl;
	out << "    mIsStaged = true;" << endl;
	out << "  return mStagedToken;" << endl;
	out << "}" << endl;
	out << endl;
}

/* Writes out the end of the file, which contains the user's postamble code. */
void WriteCppFileFooter(ostream& out, const string& postamble) {
	out << "/* START User-defined postamble code. */" << endl;
	out << postamble << endl;
	out << "/* END User-defined postamble code. */" << endl;
	out << endl;
}

/* Writes out the implementation of Lexeme. */
void WriteCppLexemeImpl(ostream& out) {
	out << "/* Implementation of Lexeme. */" << endl;
	out << "strain::Lexeme::Lexeme(const Lexeme& other) {" << endl;
	out << "  impl = other.impl->clone();" << endl;
	out << "}" << endl;
	out << endl;
	out << "strain::Lexeme& strain::Lexeme::operator= (const Lexeme& other) {" << endl;
	out << "  if (this != &other) {" << endl;
	out << "    delete impl;" << endl;
	out << "    impl = other.impl->clone();" << endl;
	out << "  }" << endl;
	out << "  return *this;" << endl;
	out << "}" << endl;
	out << endl;
	out << "strain::Lexeme::~Lexeme() {" << endl;
	out << "  delete impl;" << endl;
	out << "}" << endl;
	out << endl;
}

void CCodeGenerator::writeLexer(RegexpAutomaton automaton,
	const StrainFile& file) const {
	/* Open the output file. */
	ofstream hhOutput, cppOutput;
	hhOutput.exceptions(ios::failbit | ios::badbit);
	hhOutput.open("Lexer.hh");

	cppOutput.exceptions(ios::failbit | ios::badbit);
	cppOutput.open("Lexer.cpp");

	/* Map each state to a unique number. */
	map<MachineState*, int> stateTable;
	BuildStateTable(automaton, stateTable);

	/* Map each integer to its state. */
	vector<MachineState*> inverseStateTable(stateTable.size() - 1);
	for (map<MachineState*, int>::iterator itr = stateTable.begin();
		itr != stateTable.end(); ++itr)
		if (itr->second != -1) // Null has value -1
			inverseStateTable[itr->second] = itr->first;

	/* Write out the header file.. */
	WriteHeader(hhOutput, inverseStateTable.size(), file.tokens);

	/* Write the start of the .cpp file. */
	WriteCppFileHeader(cppOutput, file.prototypes);

	/* Write the implementation of Lexeme. */
	WriteCppLexemeImpl(cppOutput);

	/* Write out the transition tables. */
	WriteTransitionTables(cppOutput, stateTable, inverseStateTable);

	/* Write out information about what states are terminal. */
	WriteTerminalTables(cppOutput, inverseStateTable);

	/* Write out all of the typedefs necessary for the type checker. */
	WriteTokenTypedefs(cppOutput, file.tokens);

	/* Write out the semantic actions. */
	WriteSemanticActions(cppOutput, file.regexps);

	/* Write out the actual lexing function. */
	WriteLexerFunction(cppOutput);

	/* Write the footer of the .cpp file. */
	WriteCppFileFooter(cppOutput, file.implementations);
}