/* Lexer generated by strain. */
#ifndef Lexer_Included
#define Lexer_Included

#include <string>
#include <istream>
#include <utility>
#include <iterator>
#include <variant>
#include "Automaton.hh"
#include "Expression.hh"

namespace strain {
	/* An object representing some Lexeme.  This object can take on any
	 * value, and can be downcasted using the lexeme_cast function.
	 */
	class Lexeme {
	public:
		/* Default constructor for convenience. */
		Lexeme() {
			impl = 0;
		}

		/**
		 * Copy and destruction functions.
		 */

		 /* Implementation of Lexeme. */
		Lexeme(const Lexeme& other) { impl = other.impl; }

		Lexeme& operator= (const Lexeme& other) {
			if (this != &other) {
				impl = other.impl;
			}
			return *this;
		}
		~Lexeme() {}

		std::variant<int,  expr_t> impl;
#if 0
		/**
		 * const T& lexeme_cast(const Lexeme& lex);
		 * ----------------------------------------------------
		 * Downcasts the Lexeme to its stored object, throwing
		 * a bad_cast exception if the cast fails.  T must be
		 * const.
		 */

#endif
	private:
	
		friend class Lexer;

		/* Private constructor invoked by Lexer code. */
		template <typename T> Lexeme(T value) {
			impl = value;
		}
		template <typename T> Lexeme(T* value) {
			impl = expr_t(value);
		}
	public:
		template<typename T>
		const T& get() const { return std::get<T>(impl); }
		template<typename T>
		T& get()  { return std::get<T>(impl); }

		
	};

	class Lexer {
	public:
		/**
		 * Type: LexemeType
		 * ----------------------------------------------------
		 * An enumerated type corresponding to the types of each
		 * Lexeme, along with the special type None indicating
		 * that a call to next() produced no lexeme.
		 */
		enum LexemeType {
			Lexeme_Character,
			Lexeme_CharacterClass,
			Lexeme_CloseCurlyBrace,
			Lexeme_CloseParenthesis,
			Lexeme_Disjunction,
			Lexeme_EmptyString,
			Lexeme_KleeneClosure,
			Lexeme_OpenCurlyBrace,
			Lexeme_OpenParenthesis,
			Lexeme_Subtraction,
			Lexeme_Union,
			None
		};

		/**
		 * Lexer(std::istream& input);
		 * ----------------------------------------------------
		 * Constructs a new Lexer that parses input from the
		 * specified stream.
		 */
		explicit Lexer(std::istream& input) : mInput(input) {
			mIsStaged = false;
		}

		/**
		 * pair<LexemeType, Lexeme> next();
		 * ----------------------------------------------------
		 * Runs the Lexer until another token is produced,
		 * returning the pair (LexemeType, Lexeme).  If an
		 * error occurs, throws a runtime_error.  If no lexeme
		 * is produced, the LexemeType will be None.
		 */
		std::pair<LexemeType, Lexeme> next();

		/**
		 * pair<LexemeType, Lexeme> front();
		 * ----------------------------------------------------
		 * Returns, but does not consume, the next token in the
		 * sequence, throwing a runtime_error if an error occurs
		 * an producing a Lexeme of type None if no more tokens
		 * remain.
		 *
		 * This function is not const because the semantic actions
		 * associated with the produced token may have side-effects.
		 */
		std::pair<LexemeType, Lexeme> front();

	private:
		std::istream& mInput;
		bool mIsStaged; // Whether a token is staged.
		std::pair<LexemeType, Lexeme> mStagedToken;

		bool processLexeme(int state, const std::string& lexeme,
			std::pair<LexemeType, Lexeme>& out);
	};


};

#endif

