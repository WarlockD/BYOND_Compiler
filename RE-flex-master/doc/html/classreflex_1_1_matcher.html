<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>reflex::Matcher Class Reference</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">reflex::Matcher Class Reference</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Sun Sep 29 2019 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacereflex.html">reflex</a></li><li class="navelem"><a class="el" href="classreflex_1_1_matcher.html">Matcher</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classreflex_1_1_matcher-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reflex::Matcher Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>RE/flex matcher engine class, implements <a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a> pattern matching interface with scan, find, split functors and iterators.  
 <a href="classreflex_1_1_matcher.html#details">More...</a></p>

<p><code>#include &lt;matcher.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for reflex::Matcher:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_matcher__inherit__graph.png" border="0" usemap="#reflex_1_1_matcher_inherit__map" alt="Inheritance graph"/></div>
<map name="reflex_1_1_matcher_inherit__map" id="reflex_1_1_matcher_inherit__map">
<area shape="rect" id="node2" href="classreflex_1_1_pattern_matcher.html" title="reflex::PatternMatcher\l\&lt; reflex::Pattern \&gt;" alt="" coords="8,80,161,121"/>
<area shape="rect" id="node3" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines..." alt="" coords="5,5,164,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for reflex::Matcher:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_matcher__coll__graph.png" border="0" usemap="#reflex_1_1_matcher_coll__map" alt="Collaboration graph"/></div>
<map name="reflex_1_1_matcher_coll__map" id="reflex_1_1_matcher_coll__map">
<area shape="rect" id="node11" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher..." alt="" coords="1143,242,1248,269"/>
<area shape="rect" id="node2" href="classreflex_1_1_pattern_matcher.html" title="reflex::PatternMatcher\l\&lt; reflex::Pattern \&gt;" alt="" coords="1385,235,1539,276"/>
<area shape="rect" id="node3" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines..." alt="" coords="1116,71,1275,98"/>
<area shape="rect" id="node5" href="classreflex_1_1_abstract_matcher_1_1_operation.html" title="AbstractMatcher::Operation functor to match input to a pattern, also provides a (const) AbstractMatch..." alt="" coords="1383,51,1541,92"/>
<area shape="rect" id="node4" href="structreflex_1_1_abstract_matcher_1_1_option.html" title="AbstractMatcher::Options for matcher engines. " alt="" coords="875,5,1033,47"/>
<area shape="rect" id="node6" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. " alt="" coords="908,71,1000,98"/>
<area shape="rect" id="node7" title="STL class. " alt="" coords="643,66,734,93"/>
<area shape="rect" id="node8" title="STL class. " alt="" coords="365,59,494,100"/>
<area shape="rect" id="node9" title="STL class. " alt="" coords="155,66,309,93"/>
<area shape="rect" id="node10" title="STL class. " alt="" coords="5,66,105,93"/>
<area shape="rect" id="node12" href="structreflex_1_1_pattern_1_1_option.html" title="Global modifier modes, syntax flags, and compiler options. " alt="" coords="878,191,1030,218"/>
<area shape="rect" id="node13" title="STL class. " alt="" coords="389,193,469,219"/>
<area shape="rect" id="node14" title="STL class. " alt="" coords="169,185,295,227"/>
<area shape="rect" id="node21" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. " alt="" coords="616,474,761,501"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html">FSM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> data for <a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code.  <a href="structreflex_1_1_matcher_1_1_f_s_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acad91a095aa3a8e77da5d770a3c9561a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#acad91a095aa3a8e77da5d770a3c9561a">Matcher</a> ()</td></tr>
<tr class="memdesc:acad91a095aa3a8e77da5d770a3c9561a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#acad91a095aa3a8e77da5d770a3c9561a">More...</a><br /></td></tr>
<tr class="separator:acad91a095aa3a8e77da5d770a3c9561a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385c902b36f97ca11c4e46053da8dca2"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a385c902b36f97ca11c4e46053da8dca2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a385c902b36f97ca11c4e46053da8dca2">Matcher</a> (const P *<a class="el" href="classreflex_1_1_pattern_matcher.html#a05c456bf148afd72ed92f54434cad16f">pattern</a>, const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;<a class="el" href="classreflex_1_1_abstract_matcher.html#ab49c7878fc1d7c39e0ca264a5c919f08">input</a>=<a class="el" href="classreflex_1_1_input.html">Input</a>(), const char *opt=NULL)</td></tr>
<tr class="memdesc:a385c902b36f97ca11c4e46053da8dca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct matcher engine from a pattern or a string regex, and an input character sequence.  <a href="#a385c902b36f97ca11c4e46053da8dca2">More...</a><br /></td></tr>
<tr class="separator:a385c902b36f97ca11c4e46053da8dca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16be665aca5108271f92f38e6cb4bd58"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a16be665aca5108271f92f38e6cb4bd58"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a16be665aca5108271f92f38e6cb4bd58">Matcher</a> (const P &amp;<a class="el" href="classreflex_1_1_pattern_matcher.html#a05c456bf148afd72ed92f54434cad16f">pattern</a>, const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;<a class="el" href="classreflex_1_1_abstract_matcher.html#ab49c7878fc1d7c39e0ca264a5c919f08">input</a>=<a class="el" href="classreflex_1_1_input.html">Input</a>(), const char *opt=NULL)</td></tr>
<tr class="memdesc:a16be665aca5108271f92f38e6cb4bd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct matcher engine from a pattern or a string regex, and an input character sequence.  <a href="#a16be665aca5108271f92f38e6cb4bd58">More...</a><br /></td></tr>
<tr class="separator:a16be665aca5108271f92f38e6cb4bd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0ce297787f4417b00e8f0b6e325e47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#aed0ce297787f4417b00e8f0b6e325e47">Matcher</a> (const <a class="el" href="classreflex_1_1_matcher.html">Matcher</a> &amp;matcher)</td></tr>
<tr class="memdesc:aed0ce297787f4417b00e8f0b6e325e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#aed0ce297787f4417b00e8f0b6e325e47">More...</a><br /></td></tr>
<tr class="separator:aed0ce297787f4417b00e8f0b6e325e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d0469bd7c8ad7697dc877d4d30b8b5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_matcher.html">Matcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a70d0469bd7c8ad7697dc877d4d30b8b5">clone</a> ()</td></tr>
<tr class="memdesc:a70d0469bd7c8ad7697dc877d4d30b8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic cloning.  <a href="#a70d0469bd7c8ad7697dc877d4d30b8b5">More...</a><br /></td></tr>
<tr class="separator:a70d0469bd7c8ad7697dc877d4d30b8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641754cf7025a978c7dc672a563ac5c0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a641754cf7025a978c7dc672a563ac5c0">reset</a> (const char *opt=NULL)</td></tr>
<tr class="memdesc:a641754cf7025a978c7dc672a563ac5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset this matcher's state to the initial state.  <a href="#a641754cf7025a978c7dc672a563ac5c0">More...</a><br /></td></tr>
<tr class="separator:a641754cf7025a978c7dc672a563ac5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0031339b3f8426b730a6860e5feba2"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; const char *, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#acf0031339b3f8426b730a6860e5feba2">operator[]</a> (size_t n) const </td></tr>
<tr class="memdesc:acf0031339b3f8426b730a6860e5feba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns captured text as a std::pair&lt;const char*,size_t&gt; with string pointer (non-0-terminated) and length.  <a href="#acf0031339b3f8426b730a6860e5feba2">More...</a><br /></td></tr>
<tr class="separator:acf0031339b3f8426b730a6860e5feba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a835fa7ced2659ece33c458f21b1762"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a9a835fa7ced2659ece33c458f21b1762">last_stop</a> ()</td></tr>
<tr class="memdesc:a9a835fa7ced2659ece33c458f21b1762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the last indent stop.  <a href="#a9a835fa7ced2659ece33c458f21b1762">More...</a><br /></td></tr>
<tr class="separator:a9a835fa7ced2659ece33c458f21b1762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e6875f27734e64531a0e03b0521186"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a06e6875f27734e64531a0e03b0521186">insert_stop</a> (size_t n)</td></tr>
<tr class="memdesc:a06e6875f27734e64531a0e03b0521186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts or appends an indent stop position, keeping indent stops sorted.  <a href="#a06e6875f27734e64531a0e03b0521186">More...</a><br /></td></tr>
<tr class="separator:a06e6875f27734e64531a0e03b0521186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e197a62083648d93f813a00131f5b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a25e197a62083648d93f813a00131f5b9">delete_stop</a> (size_t n)</td></tr>
<tr class="memdesc:a25e197a62083648d93f813a00131f5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all stop positions from position n and up until the last.  <a href="#a25e197a62083648d93f813a00131f5b9">More...</a><br /></td></tr>
<tr class="separator:a25e197a62083648d93f813a00131f5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf84adb39572b43c63f56aecd1aaa35d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#adf84adb39572b43c63f56aecd1aaa35d">stops</a> ()</td></tr>
<tr class="memdesc:adf84adb39572b43c63f56aecd1aaa35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to vector of current indent stop positions.  <a href="#adf84adb39572b43c63f56aecd1aaa35d">More...</a><br /></td></tr>
<tr class="separator:adf84adb39572b43c63f56aecd1aaa35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cc1f381a99c834a0abf213b617b895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a06cc1f381a99c834a0abf213b617b895">clear_stops</a> ()</td></tr>
<tr class="memdesc:a06cc1f381a99c834a0abf213b617b895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear indent stop positions.  <a href="#a06cc1f381a99c834a0abf213b617b895">More...</a><br /></td></tr>
<tr class="separator:a06cc1f381a99c834a0abf213b617b895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc00e8755eeb766a180943c66786a29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#addc00e8755eeb766a180943c66786a29">push_stops</a> ()</td></tr>
<tr class="memdesc:addc00e8755eeb766a180943c66786a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push current indent stops and clear current indent stops.  <a href="#addc00e8755eeb766a180943c66786a29">More...</a><br /></td></tr>
<tr class="separator:addc00e8755eeb766a180943c66786a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363f0c0c37cbb496849034b1542e4344"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a363f0c0c37cbb496849034b1542e4344">pop_stops</a> ()</td></tr>
<tr class="memdesc:a363f0c0c37cbb496849034b1542e4344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop indent stops.  <a href="#a363f0c0c37cbb496849034b1542e4344">More...</a><br /></td></tr>
<tr class="separator:a363f0c0c37cbb496849034b1542e4344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81899695d5bb82e06e49608ed9ebd629"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a81899695d5bb82e06e49608ed9ebd629">FSM_INIT</a> (int &amp;c1)</td></tr>
<tr class="memdesc:a81899695d5bb82e06e49608ed9ebd629"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code INIT,.  <a href="#a81899695d5bb82e06e49608ed9ebd629">More...</a><br /></td></tr>
<tr class="separator:a81899695d5bb82e06e49608ed9ebd629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8c67260251d2543772fb4f04d99b9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a8a8c67260251d2543772fb4f04d99b9f">FSM_FIND</a> ()</td></tr>
<tr class="memdesc:a8a8c67260251d2543772fb4f04d99b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code FIND,.  <a href="#a8a8c67260251d2543772fb4f04d99b9f">More...</a><br /></td></tr>
<tr class="separator:a8a8c67260251d2543772fb4f04d99b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d2cbadbfa26b8b49509733971d1cc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#ae2d2cbadbfa26b8b49509733971d1cc6">FSM_CHAR</a> ()</td></tr>
<tr class="memdesc:ae2d2cbadbfa26b8b49509733971d1cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code CHAR.  <a href="#ae2d2cbadbfa26b8b49509733971d1cc6">More...</a><br /></td></tr>
<tr class="separator:ae2d2cbadbfa26b8b49509733971d1cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16876012f70f8957f689b9bda076a730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a16876012f70f8957f689b9bda076a730">FSM_HALT</a> (int c1)</td></tr>
<tr class="memdesc:a16876012f70f8957f689b9bda076a730"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code HALT.  <a href="#a16876012f70f8957f689b9bda076a730">More...</a><br /></td></tr>
<tr class="separator:a16876012f70f8957f689b9bda076a730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6237f5989d641c75edc310beb73fd84d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a6237f5989d641c75edc310beb73fd84d">FSM_TAKE</a> (<a class="el" href="classreflex_1_1_pattern.html#a38d69acf1e472d48225a3ba50b138e02">Pattern::Index</a> cap)</td></tr>
<tr class="memdesc:a6237f5989d641c75edc310beb73fd84d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code TAKE.  <a href="#a6237f5989d641c75edc310beb73fd84d">More...</a><br /></td></tr>
<tr class="separator:a6237f5989d641c75edc310beb73fd84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a041cea3bd793a450445cc82b24fc90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a1a041cea3bd793a450445cc82b24fc90">FSM_TAKE</a> (<a class="el" href="classreflex_1_1_pattern.html#a38d69acf1e472d48225a3ba50b138e02">Pattern::Index</a> cap, int c1)</td></tr>
<tr class="memdesc:a1a041cea3bd793a450445cc82b24fc90"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code TAKE.  <a href="#a1a041cea3bd793a450445cc82b24fc90">More...</a><br /></td></tr>
<tr class="separator:a1a041cea3bd793a450445cc82b24fc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899420f3b5924b6c858a862d1c3b5b71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a899420f3b5924b6c858a862d1c3b5b71">FSM_REDO</a> ()</td></tr>
<tr class="memdesc:a899420f3b5924b6c858a862d1c3b5b71"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code REDO.  <a href="#a899420f3b5924b6c858a862d1c3b5b71">More...</a><br /></td></tr>
<tr class="separator:a899420f3b5924b6c858a862d1c3b5b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29425e4f07a84ed574e99e034891493d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a29425e4f07a84ed574e99e034891493d">FSM_REDO</a> (int c1)</td></tr>
<tr class="memdesc:a29425e4f07a84ed574e99e034891493d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code REDO.  <a href="#a29425e4f07a84ed574e99e034891493d">More...</a><br /></td></tr>
<tr class="separator:a29425e4f07a84ed574e99e034891493d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf6459dd5e3c961efae5285ae1e3ad4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#abaf6459dd5e3c961efae5285ae1e3ad4">FSM_HEAD</a> (<a class="el" href="classreflex_1_1_pattern.html#a38d69acf1e472d48225a3ba50b138e02">Pattern::Index</a> la)</td></tr>
<tr class="memdesc:abaf6459dd5e3c961efae5285ae1e3ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code HEAD.  <a href="#abaf6459dd5e3c961efae5285ae1e3ad4">More...</a><br /></td></tr>
<tr class="separator:abaf6459dd5e3c961efae5285ae1e3ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bf4f34f39a43143b0942dc053c8718"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a05bf4f34f39a43143b0942dc053c8718">FSM_TAIL</a> (<a class="el" href="classreflex_1_1_pattern.html#a38d69acf1e472d48225a3ba50b138e02">Pattern::Index</a> la)</td></tr>
<tr class="memdesc:a05bf4f34f39a43143b0942dc053c8718"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code TAIL.  <a href="#a05bf4f34f39a43143b0942dc053c8718">More...</a><br /></td></tr>
<tr class="separator:a05bf4f34f39a43143b0942dc053c8718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d846e6b7fe4a8257ead872cd89515a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#ae6d846e6b7fe4a8257ead872cd89515a">FSM_DENT</a> ()</td></tr>
<tr class="memdesc:ae6d846e6b7fe4a8257ead872cd89515a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code DENT.  <a href="#ae6d846e6b7fe4a8257ead872cd89515a">More...</a><br /></td></tr>
<tr class="separator:ae6d846e6b7fe4a8257ead872cd89515a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996f60e73e31c802fac029eadac0d149"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a996f60e73e31c802fac029eadac0d149">FSM_POSN</a> ()</td></tr>
<tr class="memdesc:a996f60e73e31c802fac029eadac0d149"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> extra code POSN returns current position.  <a href="#a996f60e73e31c802fac029eadac0d149">More...</a><br /></td></tr>
<tr class="separator:a996f60e73e31c802fac029eadac0d149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e077964c3a6847b1087bed1eb77bc26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a2e077964c3a6847b1087bed1eb77bc26">FSM_BACK</a> (size_t pos)</td></tr>
<tr class="memdesc:a2e077964c3a6847b1087bed1eb77bc26"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> extra code BACK position to a previous position returned by <a class="el" href="classreflex_1_1_matcher.html#a996f60e73e31c802fac029eadac0d149" title="FSM extra code POSN returns current position. ">FSM_POSN()</a>.  <a href="#a2e077964c3a6847b1087bed1eb77bc26">More...</a><br /></td></tr>
<tr class="separator:a2e077964c3a6847b1087bed1eb77bc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441387325bdc654d53e95dafd076331c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a441387325bdc654d53e95dafd076331c">FSM_META_DED</a> ()</td></tr>
<tr class="memdesc:a441387325bdc654d53e95dafd076331c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META DED.  <a href="#a441387325bdc654d53e95dafd076331c">More...</a><br /></td></tr>
<tr class="separator:a441387325bdc654d53e95dafd076331c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920ae1d0113ba546efa140f445d18a1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a920ae1d0113ba546efa140f445d18a1a">FSM_META_IND</a> ()</td></tr>
<tr class="memdesc:a920ae1d0113ba546efa140f445d18a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META IND.  <a href="#a920ae1d0113ba546efa140f445d18a1a">More...</a><br /></td></tr>
<tr class="separator:a920ae1d0113ba546efa140f445d18a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ed3182e3f97782b8d4bb9fd090c4bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a10ed3182e3f97782b8d4bb9fd090c4bd">FSM_META_UND</a> ()</td></tr>
<tr class="memdesc:a10ed3182e3f97782b8d4bb9fd090c4bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META UND.  <a href="#a10ed3182e3f97782b8d4bb9fd090c4bd">More...</a><br /></td></tr>
<tr class="separator:a10ed3182e3f97782b8d4bb9fd090c4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acbb9557977ccf9a85f6baedc63287f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a7acbb9557977ccf9a85f6baedc63287f">FSM_META_EOB</a> (int c1)</td></tr>
<tr class="memdesc:a7acbb9557977ccf9a85f6baedc63287f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META EOB.  <a href="#a7acbb9557977ccf9a85f6baedc63287f">More...</a><br /></td></tr>
<tr class="separator:a7acbb9557977ccf9a85f6baedc63287f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852ba4d4ec243d088a1a052cab98d5b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a852ba4d4ec243d088a1a052cab98d5b2">FSM_META_BOB</a> ()</td></tr>
<tr class="memdesc:a852ba4d4ec243d088a1a052cab98d5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META BOB.  <a href="#a852ba4d4ec243d088a1a052cab98d5b2">More...</a><br /></td></tr>
<tr class="separator:a852ba4d4ec243d088a1a052cab98d5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0222ac0b08f7dfe4232cc1ae38ec86b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a0222ac0b08f7dfe4232cc1ae38ec86b0">FSM_META_EOL</a> (int c1)</td></tr>
<tr class="memdesc:a0222ac0b08f7dfe4232cc1ae38ec86b0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META EOL.  <a href="#a0222ac0b08f7dfe4232cc1ae38ec86b0">More...</a><br /></td></tr>
<tr class="separator:a0222ac0b08f7dfe4232cc1ae38ec86b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d619b6c0e42eef76e82cddea2cc8a34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a1d619b6c0e42eef76e82cddea2cc8a34">FSM_META_BOL</a> ()</td></tr>
<tr class="memdesc:a1d619b6c0e42eef76e82cddea2cc8a34"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META BOL.  <a href="#a1d619b6c0e42eef76e82cddea2cc8a34">More...</a><br /></td></tr>
<tr class="separator:a1d619b6c0e42eef76e82cddea2cc8a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d0fa7893bd165a1103aca4e8708ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a108d0fa7893bd165a1103aca4e8708ca">FSM_META_EWE</a> (int c0, int c1)</td></tr>
<tr class="memdesc:a108d0fa7893bd165a1103aca4e8708ca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META EWE.  <a href="#a108d0fa7893bd165a1103aca4e8708ca">More...</a><br /></td></tr>
<tr class="separator:a108d0fa7893bd165a1103aca4e8708ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade19817779426782ab997a7a5d8e2e3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#ade19817779426782ab997a7a5d8e2e3b">FSM_META_BWE</a> (int c0, int c1)</td></tr>
<tr class="memdesc:ade19817779426782ab997a7a5d8e2e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META BWE.  <a href="#ade19817779426782ab997a7a5d8e2e3b">More...</a><br /></td></tr>
<tr class="separator:ade19817779426782ab997a7a5d8e2e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe8cafe20bb1a1ee964b04ce7be08e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#acbe8cafe20bb1a1ee964b04ce7be08e6">FSM_META_EWB</a> ()</td></tr>
<tr class="memdesc:acbe8cafe20bb1a1ee964b04ce7be08e6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META EWB.  <a href="#acbe8cafe20bb1a1ee964b04ce7be08e6">More...</a><br /></td></tr>
<tr class="separator:acbe8cafe20bb1a1ee964b04ce7be08e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df3cef14e6011ae629e7382a87b8e2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a1df3cef14e6011ae629e7382a87b8e2a">FSM_META_BWB</a> ()</td></tr>
<tr class="memdesc:a1df3cef14e6011ae629e7382a87b8e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META BWB.  <a href="#a1df3cef14e6011ae629e7382a87b8e2a">More...</a><br /></td></tr>
<tr class="separator:a1df3cef14e6011ae629e7382a87b8e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fbd40b1c0fc532f3ec5dda683d5d86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a77fbd40b1c0fc532f3ec5dda683d5d86">FSM_META_NWE</a> (int c0, int c1)</td></tr>
<tr class="memdesc:a77fbd40b1c0fc532f3ec5dda683d5d86"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META NWE.  <a href="#a77fbd40b1c0fc532f3ec5dda683d5d86">More...</a><br /></td></tr>
<tr class="separator:a77fbd40b1c0fc532f3ec5dda683d5d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da6f6a08905ca89a5920ccd16d098dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a3da6f6a08905ca89a5920ccd16d098dd">FSM_META_NWB</a> ()</td></tr>
<tr class="memdesc:a3da6f6a08905ca89a5920ccd16d098dd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META NWB.  <a href="#a3da6f6a08905ca89a5920ccd16d098dd">More...</a><br /></td></tr>
<tr class="separator:a3da6f6a08905ca89a5920ccd16d098dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classreflex_1_1_pattern_matcher"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classreflex_1_1_pattern_matcher')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classreflex_1_1_pattern_matcher.html">reflex::PatternMatcher&lt; reflex::Pattern &gt;</a></td></tr>
<tr class="memitem:a7b32893191d6bfb4af05e33b5643b2b2 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a7b32893191d6bfb4af05e33b5643b2b2">PatternMatcher</a> (const <a class="el" href="classreflex_1_1_pattern_matcher.html">PatternMatcher</a> &amp;matcher)</td></tr>
<tr class="memdesc:a7b32893191d6bfb4af05e33b5643b2b2 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor, the underlying pattern object is shared (not deep copied).  <a href="#a7b32893191d6bfb4af05e33b5643b2b2">More...</a><br /></td></tr>
<tr class="separator:a7b32893191d6bfb4af05e33b5643b2b2 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955ab9f88de963d9f9f20da788339aea inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a955ab9f88de963d9f9f20da788339aea">~PatternMatcher</a> ()</td></tr>
<tr class="memdesc:a955ab9f88de963d9f9f20da788339aea inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete matcher, deletes pattern when owned.  <a href="#a955ab9f88de963d9f9f20da788339aea">More...</a><br /></td></tr>
<tr class="separator:a955ab9f88de963d9f9f20da788339aea inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c456bf148afd72ed92f54434cad16f inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_pattern_matcher.html">PatternMatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a05c456bf148afd72ed92f54434cad16f">pattern</a> (const <a class="el" href="classreflex_1_1_pattern_matcher.html">PatternMatcher</a> &amp;matcher)</td></tr>
<tr class="memdesc:a05c456bf148afd72ed92f54434cad16f inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the pattern to use with this matcher as a shared pointer to another matcher pattern.  <a href="#a05c456bf148afd72ed92f54434cad16f">More...</a><br /></td></tr>
<tr class="separator:a05c456bf148afd72ed92f54434cad16f inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89879ab1c62ff5e3ccca4fa38f48a65c inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_pattern_matcher.html">PatternMatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a89879ab1c62ff5e3ccca4fa38f48a65c">pattern</a> (const <a class="el" href="classreflex_1_1_pattern_matcher.html#a56c667f62f9d60ccfe3caf16bbc2a9fc">Pattern</a> &amp;pattern)</td></tr>
<tr class="memdesc:a89879ab1c62ff5e3ccca4fa38f48a65c inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the pattern to use with this matcher (the given pattern is shared and must be persistent).  <a href="#a89879ab1c62ff5e3ccca4fa38f48a65c">More...</a><br /></td></tr>
<tr class="separator:a89879ab1c62ff5e3ccca4fa38f48a65c inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab943ef5b146c1318f42a5819ece76756 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_pattern_matcher.html">PatternMatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#ab943ef5b146c1318f42a5819ece76756">pattern</a> (const <a class="el" href="classreflex_1_1_pattern_matcher.html#a56c667f62f9d60ccfe3caf16bbc2a9fc">Pattern</a> *pattern)</td></tr>
<tr class="memdesc:ab943ef5b146c1318f42a5819ece76756 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the pattern to use with this matcher (the given pattern is shared and must be persistent).  <a href="#ab943ef5b146c1318f42a5819ece76756">More...</a><br /></td></tr>
<tr class="separator:ab943ef5b146c1318f42a5819ece76756 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9a83c590efff2b6e8c5ee4ce894ac1 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_pattern_matcher.html">PatternMatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a3d9a83c590efff2b6e8c5ee4ce894ac1">pattern</a> (const char *pattern)</td></tr>
<tr class="memdesc:a3d9a83c590efff2b6e8c5ee4ce894ac1 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the pattern from a regex string to use with this matcher.  <a href="#a3d9a83c590efff2b6e8c5ee4ce894ac1">More...</a><br /></td></tr>
<tr class="separator:a3d9a83c590efff2b6e8c5ee4ce894ac1 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9486bcf9076f7a904e3d0f73ba855c6 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_pattern_matcher.html">PatternMatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#af9486bcf9076f7a904e3d0f73ba855c6">pattern</a> (const std::string &amp;pattern)</td></tr>
<tr class="memdesc:af9486bcf9076f7a904e3d0f73ba855c6 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the pattern from a regex string to use with this matcher.  <a href="#af9486bcf9076f7a904e3d0f73ba855c6">More...</a><br /></td></tr>
<tr class="separator:af9486bcf9076f7a904e3d0f73ba855c6 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb2eacba4c6b5a62d9c42e8bbdc2c63 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classreflex_1_1_pattern_matcher.html#a56c667f62f9d60ccfe3caf16bbc2a9fc">Pattern</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a3cb2eacba4c6b5a62d9c42e8bbdc2c63">pattern</a> () const</td></tr>
<tr class="memdesc:a3cb2eacba4c6b5a62d9c42e8bbdc2c63 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the pattern object associated with this matcher.  <a href="#a3cb2eacba4c6b5a62d9c42e8bbdc2c63">More...</a><br /></td></tr>
<tr class="separator:a3cb2eacba4c6b5a62d9c42e8bbdc2c63 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac868861b716ce41e26f4a589517ae088 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#ac868861b716ce41e26f4a589517ae088">has_pattern</a> () const</td></tr>
<tr class="memdesc:ac868861b716ce41e26f4a589517ae088 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher has a pattern.  <a href="#ac868861b716ce41e26f4a589517ae088">More...</a><br /></td></tr>
<tr class="separator:ac868861b716ce41e26f4a589517ae088 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1e17bf52c960356ba7308015e98a49 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a5f1e17bf52c960356ba7308015e98a49">own_pattern</a> () const</td></tr>
<tr class="memdesc:a5f1e17bf52c960356ba7308015e98a49 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher has its own pattern not received from another matcher (responsible to delete).  <a href="#a5f1e17bf52c960356ba7308015e98a49">More...</a><br /></td></tr>
<tr class="separator:a5f1e17bf52c960356ba7308015e98a49 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classreflex_1_1_abstract_matcher"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classreflex_1_1_abstract_matcher')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classreflex_1_1_abstract_matcher.html">reflex::AbstractMatcher</a></td></tr>
<tr class="memitem:a1678067737066140c605e4e2e65ad1bb inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a1678067737066140c605e4e2e65ad1bb">AbstractMatcher</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;<a class="el" href="classreflex_1_1_abstract_matcher.html#ab49c7878fc1d7c39e0ca264a5c919f08">input</a>, const char *opt)</td></tr>
<tr class="memdesc:a1678067737066140c605e4e2e65ad1bb inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a base abstract matcher.  <a href="#a1678067737066140c605e4e2e65ad1bb">More...</a><br /></td></tr>
<tr class="separator:a1678067737066140c605e4e2e65ad1bb inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa845e2492e9dfae56e9192c8330143b inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#afa845e2492e9dfae56e9192c8330143b">AbstractMatcher</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;<a class="el" href="classreflex_1_1_abstract_matcher.html#ab49c7878fc1d7c39e0ca264a5c919f08">input</a>, const <a class="el" href="structreflex_1_1_abstract_matcher_1_1_option.html">Option</a> &amp;opt)</td></tr>
<tr class="memdesc:afa845e2492e9dfae56e9192c8330143b inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a base abstract matcher.  <a href="#afa845e2492e9dfae56e9192c8330143b">More...</a><br /></td></tr>
<tr class="separator:afa845e2492e9dfae56e9192c8330143b inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1687bb274cfa3af4de2cc8f0e9fcd10d inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a1687bb274cfa3af4de2cc8f0e9fcd10d">~AbstractMatcher</a> ()</td></tr>
<tr class="memdesc:a1687bb274cfa3af4de2cc8f0e9fcd10d inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete abstract matcher, deletes this matcher's internal buffer.  <a href="#a1687bb274cfa3af4de2cc8f0e9fcd10d">More...</a><br /></td></tr>
<tr class="separator:a1687bb274cfa3af4de2cc8f0e9fcd10d inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb96965d228951194f0a2b9ee574dcf inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a0fb96965d228951194f0a2b9ee574dcf">buffer</a> (size_t blk=0)</td></tr>
<tr class="memdesc:a0fb96965d228951194f0a2b9ee574dcf inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set buffer block size for reading: use 1 for interactive input, 0 (or omit argument) to buffer all input in which case returns true if all the data could be read and false if a read error occurred.  <a href="#a0fb96965d228951194f0a2b9ee574dcf">More...</a><br /></td></tr>
<tr class="separator:a0fb96965d228951194f0a2b9ee574dcf inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1d22133cb4cf88f208c45ee8cdc0e0 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#acb1d22133cb4cf88f208c45ee8cdc0e0">interactive</a> ()</td></tr>
<tr class="memdesc:acb1d22133cb4cf88f208c45ee8cdc0e0 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set buffer to 1 for interactive input.  <a href="#acb1d22133cb4cf88f208c45ee8cdc0e0">More...</a><br /></td></tr>
<tr class="separator:acb1d22133cb4cf88f208c45ee8cdc0e0 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafc5782952bb1e80c7e5bf367ffc6af inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#acafc5782952bb1e80c7e5bf367ffc6af">flush</a> ()</td></tr>
<tr class="memdesc:acafc5782952bb1e80c7e5bf367ffc6af inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the buffer's remaining content.  <a href="#acafc5782952bb1e80c7e5bf367ffc6af">More...</a><br /></td></tr>
<tr class="separator:acafc5782952bb1e80c7e5bf367ffc6af inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49c7878fc1d7c39e0ca264a5c919f08 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ab49c7878fc1d7c39e0ca264a5c919f08">input</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;input)</td></tr>
<tr class="memdesc:ab49c7878fc1d7c39e0ca264a5c919f08 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the input character sequence for this matcher and reset/restart the matcher.  <a href="#ab49c7878fc1d7c39e0ca264a5c919f08">More...</a><br /></td></tr>
<tr class="separator:ab49c7878fc1d7c39e0ca264a5c919f08 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3939efa95649d0b8543109669818a097 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a3939efa95649d0b8543109669818a097">buffer</a> (char *base, size_t <a class="el" href="classreflex_1_1_abstract_matcher.html#adb5fec59e6c6a86b8cf405c40f93d1de">size</a>)</td></tr>
<tr class="memdesc:a3939efa95649d0b8543109669818a097 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buffer base containing 0-terminated character data to scan in place (data may be modified), reset/restart the matcher.  <a href="#a3939efa95649d0b8543109669818a097">More...</a><br /></td></tr>
<tr class="separator:a3939efa95649d0b8543109669818a097 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab880e6c8fe0df7c4ee7bb629aab41d0f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ab880e6c8fe0df7c4ee7bb629aab41d0f">matches</a> ()</td></tr>
<tr class="memdesc:ab880e6c8fe0df7c4ee7bb629aab41d0f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns nonzero capture index (i.e. true) if the entire input matches this matcher's pattern (and internally caches the true/false result for repeat invocations).  <a href="#ab880e6c8fe0df7c4ee7bb629aab41d0f">More...</a><br /></td></tr>
<tr class="separator:ab880e6c8fe0df7c4ee7bb629aab41d0f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51252ce359e6106b58c81f70776ccfb inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb">accept</a> () const </td></tr>
<tr class="memdesc:af51252ce359e6106b58c81f70776ccfb inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a positive integer (true) indicating the capture index of the matched text in the pattern or zero (false) for a mismatch.  <a href="#af51252ce359e6106b58c81f70776ccfb">More...</a><br /></td></tr>
<tr class="separator:af51252ce359e6106b58c81f70776ccfb inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329001b2880a756dd4d6f6fd0192d004 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a329001b2880a756dd4d6f6fd0192d004">begin</a> () const </td></tr>
<tr class="memdesc:a329001b2880a756dd4d6f6fd0192d004 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the begin of the matched text (non-0-terminated), a constant-time operation, use with <a class="el" href="classreflex_1_1_abstract_matcher.html#aaf1c25cf25951b7eeda7aa50d4736fd4" title="Returns pointer to the end of the matched text, a constant-time operation. ">end()</a> or use <a class="el" href="classreflex_1_1_abstract_matcher.html#adb5fec59e6c6a86b8cf405c40f93d1de" title="Returns the length of the matched text in number of bytes, including matched \0s, a constant-time ope...">size()</a> for text end/length.  <a href="#a329001b2880a756dd4d6f6fd0192d004">More...</a><br /></td></tr>
<tr class="separator:a329001b2880a756dd4d6f6fd0192d004 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1c25cf25951b7eeda7aa50d4736fd4 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aaf1c25cf25951b7eeda7aa50d4736fd4">end</a> () const </td></tr>
<tr class="memdesc:aaf1c25cf25951b7eeda7aa50d4736fd4 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the end of the matched text, a constant-time operation.  <a href="#aaf1c25cf25951b7eeda7aa50d4736fd4">More...</a><br /></td></tr>
<tr class="separator:aaf1c25cf25951b7eeda7aa50d4736fd4 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009bad2d87f9bc2f18a9ae52cc08b9e1 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1">text</a> ()</td></tr>
<tr class="memdesc:a009bad2d87f9bc2f18a9ae52cc08b9e1 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 0-terminated string of the text matched, does not include matched \0s, a constant-time operation.  <a href="#a009bad2d87f9bc2f18a9ae52cc08b9e1">More...</a><br /></td></tr>
<tr class="separator:a009bad2d87f9bc2f18a9ae52cc08b9e1 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1d2913a158699703eee6d5f603701b inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a9c1d2913a158699703eee6d5f603701b">str</a> () const </td></tr>
<tr class="memdesc:a9c1d2913a158699703eee6d5f603701b inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the text matched as a string, a copy of <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated string of the text matched, does not include matched \0s, a constant-time operat...">text()</a>, may include matched \0s.  <a href="#a9c1d2913a158699703eee6d5f603701b">More...</a><br /></td></tr>
<tr class="separator:a9c1d2913a158699703eee6d5f603701b inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cef361d991985fc4b28166d91ee15d inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a28cef361d991985fc4b28166d91ee15d">wstr</a> () const </td></tr>
<tr class="memdesc:a28cef361d991985fc4b28166d91ee15d inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the match as a wide string, converted from UTF-8 <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated string of the text matched, does not include matched \0s, a constant-time operat...">text()</a>, may include matched \0s.  <a href="#a28cef361d991985fc4b28166d91ee15d">More...</a><br /></td></tr>
<tr class="separator:a28cef361d991985fc4b28166d91ee15d inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5fec59e6c6a86b8cf405c40f93d1de inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#adb5fec59e6c6a86b8cf405c40f93d1de">size</a> () const </td></tr>
<tr class="memdesc:adb5fec59e6c6a86b8cf405c40f93d1de inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the matched text in number of bytes, including matched \0s, a constant-time operation.  <a href="#adb5fec59e6c6a86b8cf405c40f93d1de">More...</a><br /></td></tr>
<tr class="separator:adb5fec59e6c6a86b8cf405c40f93d1de inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bcff50974291fa01d4f7f7db4c77f5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#af4bcff50974291fa01d4f7f7db4c77f5">wsize</a> () const </td></tr>
<tr class="memdesc:af4bcff50974291fa01d4f7f7db4c77f5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the matched text in number of wide characters.  <a href="#af4bcff50974291fa01d4f7f7db4c77f5">More...</a><br /></td></tr>
<tr class="separator:af4bcff50974291fa01d4f7f7db4c77f5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e24702dba5c0c15e5f680b174a4758 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a12e24702dba5c0c15e5f680b174a4758">chr</a> () const </td></tr>
<tr class="memdesc:a12e24702dba5c0c15e5f680b174a4758 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first 8-bit character of the text matched.  <a href="#a12e24702dba5c0c15e5f680b174a4758">More...</a><br /></td></tr>
<tr class="separator:a12e24702dba5c0c15e5f680b174a4758 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b7e09cf2e74ffbf09fb65ebac337f5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aa1b7e09cf2e74ffbf09fb65ebac337f5">wchr</a> () const </td></tr>
<tr class="memdesc:aa1b7e09cf2e74ffbf09fb65ebac337f5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first wide character of the text matched.  <a href="#aa1b7e09cf2e74ffbf09fb65ebac337f5">More...</a><br /></td></tr>
<tr class="separator:aa1b7e09cf2e74ffbf09fb65ebac337f5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbfcc6386048d9c3613f7de919ba242 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a3bbfcc6386048d9c3613f7de919ba242">lineno</a> ()</td></tr>
<tr class="memdesc:a3bbfcc6386048d9c3613f7de919ba242 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates and returns the starting line number of the match in the input character sequence.  <a href="#a3bbfcc6386048d9c3613f7de919ba242">More...</a><br /></td></tr>
<tr class="separator:a3bbfcc6386048d9c3613f7de919ba242 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0effb0f81dc4913f09efef0836690fa9 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a0effb0f81dc4913f09efef0836690fa9">lines</a> () const </td></tr>
<tr class="memdesc:a0effb0f81dc4913f09efef0836690fa9 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of lines that the match spans.  <a href="#a0effb0f81dc4913f09efef0836690fa9">More...</a><br /></td></tr>
<tr class="separator:a0effb0f81dc4913f09efef0836690fa9 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51527a637b1964627dd34c722d905b65 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a51527a637b1964627dd34c722d905b65">columno</a> ()</td></tr>
<tr class="memdesc:a51527a637b1964627dd34c722d905b65 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates and returns the starting column number of matched text, taking tab spacing into account and counting wide characters as one character each (unless compiled with WITH_BYTE_COLUMNO).  <a href="#a51527a637b1964627dd34c722d905b65">More...</a><br /></td></tr>
<tr class="separator:a51527a637b1964627dd34c722d905b65 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebecc394164677b4ad49f68478e61d5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#afebecc394164677b4ad49f68478e61d5">columns</a> () const </td></tr>
<tr class="memdesc:afebecc394164677b4ad49f68478e61d5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns of the last line (or the single line of matched text) in the matched text, taking tab spacing into account and counting wide characters as one character each (unless compiled with WITH_BYTE_COLUMNO).  <a href="#afebecc394164677b4ad49f68478e61d5">More...</a><br /></td></tr>
<tr class="separator:afebecc394164677b4ad49f68478e61d5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc573eafc849b275d21b114abe1ea570 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#abc573eafc849b275d21b114abe1ea570">pair</a> () const </td></tr>
<tr class="memdesc:abc573eafc849b275d21b114abe1ea570 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns std::pair&lt;size_t,std::string&gt;(<a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a9c1d2913a158699703eee6d5f603701b" title="Returns the text matched as a string, a copy of text(), may include matched \0s. ">str()</a>), useful for tokenizing input into containers of pairs.  <a href="#abc573eafc849b275d21b114abe1ea570">More...</a><br /></td></tr>
<tr class="separator:abc573eafc849b275d21b114abe1ea570 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51a6d149b4147a1ac7d64b2d6587bd3 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, std::wstring &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ae51a6d149b4147a1ac7d64b2d6587bd3">wpair</a> () const </td></tr>
<tr class="memdesc:ae51a6d149b4147a1ac7d64b2d6587bd3 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns std::pair&lt;size_t,std::wstring&gt;(<a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a28cef361d991985fc4b28166d91ee15d" title="Returns the match as a wide string, converted from UTF-8 text(), may include matched \0s...">wstr()</a>), useful for tokenizing input into containers of pairs.  <a href="#ae51a6d149b4147a1ac7d64b2d6587bd3">More...</a><br /></td></tr>
<tr class="separator:ae51a6d149b4147a1ac7d64b2d6587bd3 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112117a78682b9634806158e018dc6b4 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a112117a78682b9634806158e018dc6b4">first</a> () const </td></tr>
<tr class="memdesc:a112117a78682b9634806158e018dc6b4 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first character of the match in the input character sequence, a constant-time operation.  <a href="#a112117a78682b9634806158e018dc6b4">More...</a><br /></td></tr>
<tr class="separator:a112117a78682b9634806158e018dc6b4 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7840043710c3c45820390480c8f42315 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7840043710c3c45820390480c8f42315">last</a> () const </td></tr>
<tr class="memdesc:a7840043710c3c45820390480c8f42315 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the last character + 1 of the match in the input character sequence, a constant-time operation.  <a href="#a7840043710c3c45820390480c8f42315">More...</a><br /></td></tr>
<tr class="separator:a7840043710c3c45820390480c8f42315 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146013ac9f6dcb1af9edef6ee5f3dc58 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a146013ac9f6dcb1af9edef6ee5f3dc58">at_bob</a> () const </td></tr>
<tr class="memdesc:a146013ac9f6dcb1af9edef6ee5f3dc58 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher is at the start of a buffer to read an input character sequence. Use <a class="el" href="classreflex_1_1_abstract_matcher.html#a66f487ab96e7cef1a66e9780dc45e315" title="Reset this matcher&#39;s state to the initial state and set options (when provided). ">reset()</a> to restart reading new input.  <a href="#a146013ac9f6dcb1af9edef6ee5f3dc58">More...</a><br /></td></tr>
<tr class="separator:a146013ac9f6dcb1af9edef6ee5f3dc58 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0b546187f2ad8f6d7f39207e683a7f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a8e0b546187f2ad8f6d7f39207e683a7f">set_bob</a> (bool bob)</td></tr>
<tr class="memdesc:a8e0b546187f2ad8f6d7f39207e683a7f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/reset the begin of a buffer state.  <a href="#a8e0b546187f2ad8f6d7f39207e683a7f">More...</a><br /></td></tr>
<tr class="separator:a8e0b546187f2ad8f6d7f39207e683a7f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac843ab490d5ad9ba71a96c3b323eba19 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ac843ab490d5ad9ba71a96c3b323eba19">at_end</a> ()</td></tr>
<tr class="memdesc:ac843ab490d5ad9ba71a96c3b323eba19 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher has no more input to read from the input character sequence.  <a href="#ac843ab490d5ad9ba71a96c3b323eba19">More...</a><br /></td></tr>
<tr class="separator:ac843ab490d5ad9ba71a96c3b323eba19 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5ec19555d6e0f4a8210651f9343987 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#afb5ec19555d6e0f4a8210651f9343987">hit_end</a> () const </td></tr>
<tr class="memdesc:afb5ec19555d6e0f4a8210651f9343987 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher hit the end of the input character sequence.  <a href="#afb5ec19555d6e0f4a8210651f9343987">More...</a><br /></td></tr>
<tr class="separator:afb5ec19555d6e0f4a8210651f9343987 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6dcc2b180a7139b52a6bfe1ebabf1b inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aec6dcc2b180a7139b52a6bfe1ebabf1b">set_end</a> (bool eof)</td></tr>
<tr class="memdesc:aec6dcc2b180a7139b52a6bfe1ebabf1b inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set and force the end of input state.  <a href="#aec6dcc2b180a7139b52a6bfe1ebabf1b">More...</a><br /></td></tr>
<tr class="separator:aec6dcc2b180a7139b52a6bfe1ebabf1b inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240d7d235b5a1d7aa32d464891cb96a5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a240d7d235b5a1d7aa32d464891cb96a5">at_bol</a> () const </td></tr>
<tr class="memdesc:a240d7d235b5a1d7aa32d464891cb96a5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher reached the begin of a new line.  <a href="#a240d7d235b5a1d7aa32d464891cb96a5">More...</a><br /></td></tr>
<tr class="separator:a240d7d235b5a1d7aa32d464891cb96a5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0860fa58e41f5a0d7e74d1fe33559df3 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a0860fa58e41f5a0d7e74d1fe33559df3">set_bol</a> (bool bol)</td></tr>
<tr class="memdesc:a0860fa58e41f5a0d7e74d1fe33559df3 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/reset the begin of a new line state.  <a href="#a0860fa58e41f5a0d7e74d1fe33559df3">More...</a><br /></td></tr>
<tr class="separator:a0860fa58e41f5a0d7e74d1fe33559df3 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2eb7cb29b0fd2c87aade0db5b3ab10 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a4d2eb7cb29b0fd2c87aade0db5b3ab10">at_bow</a> ()</td></tr>
<tr class="memdesc:a4d2eb7cb29b0fd2c87aade0db5b3ab10 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher matched text that begins a word.  <a href="#a4d2eb7cb29b0fd2c87aade0db5b3ab10">More...</a><br /></td></tr>
<tr class="separator:a4d2eb7cb29b0fd2c87aade0db5b3ab10 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17b43ef74d35dc503f8057ec410a3fa inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ac17b43ef74d35dc503f8057ec410a3fa">at_eow</a> ()</td></tr>
<tr class="memdesc:ac17b43ef74d35dc503f8057ec410a3fa inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher matched text that ends a word.  <a href="#ac17b43ef74d35dc503f8057ec410a3fa">More...</a><br /></td></tr>
<tr class="separator:ac17b43ef74d35dc503f8057ec410a3fa inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827817fd1ed8edbe8eec84eeefa8a88e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a827817fd1ed8edbe8eec84eeefa8a88e">input</a> ()</td></tr>
<tr class="memdesc:a827817fd1ed8edbe8eec84eeefa8a88e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next 8-bit character (unsigned char 0..255 or EOF) from the input character sequence, while preserving the current <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated string of the text matched, does not include matched \0s, a constant-time operat...">text()</a> match (but pointer returned by <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated string of the text matched, does not include matched \0s, a constant-time operat...">text()</a> may change; warning: does not preserve the yytext string pointer when options &ndash;flex and &ndash;bison are used).  <a href="#a827817fd1ed8edbe8eec84eeefa8a88e">More...</a><br /></td></tr>
<tr class="separator:a827817fd1ed8edbe8eec84eeefa8a88e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee94acd13edc05acfa087499d650a8f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a6ee94acd13edc05acfa087499d650a8f">winput</a> ()</td></tr>
<tr class="memdesc:a6ee94acd13edc05acfa087499d650a8f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next wide character (unsigned 0..U+10FFFF or EOF) from the input character sequence, while preserving the current <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated string of the text matched, does not include matched \0s, a constant-time operat...">text()</a> match (but pointer returned by <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated string of the text matched, does not include matched \0s, a constant-time operat...">text()</a> may change; warning: does not preserve the yytext string pointer when options &ndash;flex and &ndash;bison are used).  <a href="#a6ee94acd13edc05acfa087499d650a8f">More...</a><br /></td></tr>
<tr class="separator:a6ee94acd13edc05acfa087499d650a8f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb536d7812fcf52017e9d452e96381a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a5fb536d7812fcf52017e9d452e96381a">unput</a> (char c)</td></tr>
<tr class="memdesc:a5fb536d7812fcf52017e9d452e96381a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put back one character (8-bit) on the input character sequence for matching, invalidates the current match info and text, unput is not honored when matching in-place using buffer(base, size) and nothing has been read yet.  <a href="#a5fb536d7812fcf52017e9d452e96381a">More...</a><br /></td></tr>
<tr class="separator:a5fb536d7812fcf52017e9d452e96381a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8a8eff9fc980c7028c9399a1310849 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#acb8a8eff9fc980c7028c9399a1310849">peek</a> ()</td></tr>
<tr class="memdesc:acb8a8eff9fc980c7028c9399a1310849 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the next character available for reading from the current input source.  <a href="#acb8a8eff9fc980c7028c9399a1310849">More...</a><br /></td></tr>
<tr class="separator:acb8a8eff9fc980c7028c9399a1310849 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39dc592de42a7e044296f03bee4fdb3 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ab39dc592de42a7e044296f03bee4fdb3">rest</a> ()</td></tr>
<tr class="memdesc:ab39dc592de42a7e044296f03bee4fdb3 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the rest of the input as text, useful for searching/splitting up to n times after which the rest is needed.  <a href="#ab39dc592de42a7e044296f03bee4fdb3">More...</a><br /></td></tr>
<tr class="separator:ab39dc592de42a7e044296f03bee4fdb3 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9577e765c5c1be82cb3f9b0ccdaf633f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a9577e765c5c1be82cb3f9b0ccdaf633f">more</a> ()</td></tr>
<tr class="memdesc:a9577e765c5c1be82cb3f9b0ccdaf633f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the next match to the currently matched text returned by <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated string of the text matched, does not include matched \0s, a constant-time operat...">AbstractMatcher::text</a>, when the next match found is adjacent to the current match.  <a href="#a9577e765c5c1be82cb3f9b0ccdaf633f">More...</a><br /></td></tr>
<tr class="separator:a9577e765c5c1be82cb3f9b0ccdaf633f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ca0aa2d6ff88ac26f565ec5660787a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a12ca0aa2d6ff88ac26f565ec5660787a">less</a> (size_t n)</td></tr>
<tr class="memdesc:a12ca0aa2d6ff88ac26f565ec5660787a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate the <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated string of the text matched, does not include matched \0s, a constant-time operat...">AbstractMatcher::text</a> length of the match to n characters in length and reposition for next match.  <a href="#a12ca0aa2d6ff88ac26f565ec5660787a">More...</a><br /></td></tr>
<tr class="separator:a12ca0aa2d6ff88ac26f565ec5660787a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8cd6c7fde713a5ac68ec168291e03e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a2e8cd6c7fde713a5ac68ec168291e03e">operator size_t</a> () const </td></tr>
<tr class="memdesc:a2e8cd6c7fde713a5ac68ec168291e03e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this matcher to positive integer indicating the nonzero capture index of the matched text in the pattern, same as <a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">AbstractMatcher::accept</a>.  <a href="#a2e8cd6c7fde713a5ac68ec168291e03e">More...</a><br /></td></tr>
<tr class="separator:a2e8cd6c7fde713a5ac68ec168291e03e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360028bf97e0da02f6ffbcae031f9f35 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a360028bf97e0da02f6ffbcae031f9f35">operator std::string</a> () const </td></tr>
<tr class="memdesc:a360028bf97e0da02f6ffbcae031f9f35 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this matcher to a std::string of the text matched by this matcher.  <a href="#a360028bf97e0da02f6ffbcae031f9f35">More...</a><br /></td></tr>
<tr class="separator:a360028bf97e0da02f6ffbcae031f9f35 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1c0ee67ce2062f8c1c518170cd2a74 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aab1c0ee67ce2062f8c1c518170cd2a74">operator std::wstring</a> () const </td></tr>
<tr class="memdesc:aab1c0ee67ce2062f8c1c518170cd2a74 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this matcher to a std::wstring of the text matched by this matcher.  <a href="#aab1c0ee67ce2062f8c1c518170cd2a74">More...</a><br /></td></tr>
<tr class="separator:aab1c0ee67ce2062f8c1c518170cd2a74 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aeee06821a94df33a8c531d3913a5d7 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a6aeee06821a94df33a8c531d3913a5d7">operator std::pair&lt; size_t, std::string &gt;</a> () const </td></tr>
<tr class="memdesc:a6aeee06821a94df33a8c531d3913a5d7 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the match to std::pair&lt;size_t,std::wstring&gt;(<a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a28cef361d991985fc4b28166d91ee15d" title="Returns the match as a wide string, converted from UTF-8 text(), may include matched \0s...">wstr()</a>), useful for tokenization into containers.  <a href="#a6aeee06821a94df33a8c531d3913a5d7">More...</a><br /></td></tr>
<tr class="separator:a6aeee06821a94df33a8c531d3913a5d7 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ccba7e796bc4cbf0fca4ddca5c7435 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ac0ccba7e796bc4cbf0fca4ddca5c7435">operator==</a> (const char *rhs) const </td></tr>
<tr class="memdesc:ac0ccba7e796bc4cbf0fca4ddca5c7435 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matched text is equal to a string, useful for std::algorithm.  <a href="#ac0ccba7e796bc4cbf0fca4ddca5c7435">More...</a><br /></td></tr>
<tr class="separator:ac0ccba7e796bc4cbf0fca4ddca5c7435 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80d8b2a00e7e4342187f3e820aae4cc inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ad80d8b2a00e7e4342187f3e820aae4cc">operator==</a> (const std::string &amp;rhs) const </td></tr>
<tr class="memdesc:ad80d8b2a00e7e4342187f3e820aae4cc inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matched text is equalt to a string, useful for std::algorithm.  <a href="#ad80d8b2a00e7e4342187f3e820aae4cc">More...</a><br /></td></tr>
<tr class="separator:ad80d8b2a00e7e4342187f3e820aae4cc inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bd073a805aa84f99af13d4f4d7810a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ac9bd073a805aa84f99af13d4f4d7810a">operator==</a> (size_t rhs) const </td></tr>
<tr class="memdesc:ac9bd073a805aa84f99af13d4f4d7810a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if capture index is equal to a given size_t value, useful for std::algorithm.  <a href="#ac9bd073a805aa84f99af13d4f4d7810a">More...</a><br /></td></tr>
<tr class="separator:ac9bd073a805aa84f99af13d4f4d7810a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca9e1c83a9e7ea32adc7dedcba8891e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aeca9e1c83a9e7ea32adc7dedcba8891e">operator==</a> (int rhs) const </td></tr>
<tr class="memdesc:aeca9e1c83a9e7ea32adc7dedcba8891e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if capture index is equal to a given int value, useful for std::algorithm.  <a href="#aeca9e1c83a9e7ea32adc7dedcba8891e">More...</a><br /></td></tr>
<tr class="separator:aeca9e1c83a9e7ea32adc7dedcba8891e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502f0e864626cbdc5a09b6045c7fd801 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a502f0e864626cbdc5a09b6045c7fd801">operator!=</a> (const char *rhs) const </td></tr>
<tr class="memdesc:a502f0e864626cbdc5a09b6045c7fd801 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matched text is not equal to a string, useful for std::algorithm.  <a href="#a502f0e864626cbdc5a09b6045c7fd801">More...</a><br /></td></tr>
<tr class="separator:a502f0e864626cbdc5a09b6045c7fd801 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85763cb3d9dbb87906edb69545d4f616 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a85763cb3d9dbb87906edb69545d4f616">operator!=</a> (const std::string &amp;rhs) const </td></tr>
<tr class="memdesc:a85763cb3d9dbb87906edb69545d4f616 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matched text is not equal to a string, useful for std::algorithm.  <a href="#a85763cb3d9dbb87906edb69545d4f616">More...</a><br /></td></tr>
<tr class="separator:a85763cb3d9dbb87906edb69545d4f616 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e20564598a3871d32d95af33db5ea4 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a08e20564598a3871d32d95af33db5ea4">operator!=</a> (size_t rhs) const </td></tr>
<tr class="memdesc:a08e20564598a3871d32d95af33db5ea4 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if capture index is not equal to a given size_t value, useful for std::algorithm.  <a href="#a08e20564598a3871d32d95af33db5ea4">More...</a><br /></td></tr>
<tr class="separator:a08e20564598a3871d32d95af33db5ea4 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7157e28939ecc094dca648b3bf9759a2 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7157e28939ecc094dca648b3bf9759a2">operator!=</a> (int rhs) const </td></tr>
<tr class="memdesc:a7157e28939ecc094dca648b3bf9759a2 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if capture index is not equal to a given int value, useful for std::algorithm.  <a href="#a7157e28939ecc094dca648b3bf9759a2">More...</a><br /></td></tr>
<tr class="separator:a7157e28939ecc094dca648b3bf9759a2 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56a20f5b1cb4d25faea0e40508900c0 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ae56a20f5b1cb4d25faea0e40508900c0">tabs</a> (char n)</td></tr>
<tr class="memdesc:ae56a20f5b1cb4d25faea0e40508900c0 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set tab size 1, 2, 4, or 8.  <a href="#ae56a20f5b1cb4d25faea0e40508900c0">More...</a><br /></td></tr>
<tr class="separator:ae56a20f5b1cb4d25faea0e40508900c0 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfeac276b47b376ed2d8ace623d75efe inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#adfeac276b47b376ed2d8ace623d75efe">tabs</a> ()</td></tr>
<tr class="memdesc:adfeac276b47b376ed2d8ace623d75efe inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current tab size 1, 2, 4, or 8.  <a href="#adfeac276b47b376ed2d8ace623d75efe">More...</a><br /></td></tr>
<tr class="separator:adfeac276b47b376ed2d8ace623d75efe inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8862686f6d5680d4d0e5af146c4aed69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8862686f6d5680d4d0e5af146c4aed69"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a8862686f6d5680d4d0e5af146c4aed69">convert</a> (T regex, <a class="el" href="namespacereflex.html#ab659f1b759d66631c2e2e32771af1200">convert_flag_type</a> flags=<a class="el" href="namespacereflex_1_1convert__flag.html#af5c6fe22fc79bb893e135d583d525930">convert_flag::none</a>)</td></tr>
<tr class="memdesc:a8862686f6d5680d4d0e5af146c4aed69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a regex to an acceptable form, given the specified regex library signature <code>"[decls:]escapes[?+]"</code>, see <a class="el" href="namespacereflex.html#a4f388dfde137fe178705346b44c56223" title="Returns the converted regex string given a regex library signature and conversion flags...">reflex::convert</a>.  <a href="#a8862686f6d5680d4d0e5af146c4aed69">More...</a><br /></td></tr>
<tr class="separator:a8862686f6d5680d4d0e5af146c4aed69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a9748ab7e9dc48d3893968f432a3f7cfa"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a9748ab7e9dc48d3893968f432a3f7cfa">Stops</a></td></tr>
<tr class="separator:a9748ab7e9dc48d3893968f432a3f7cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classreflex_1_1_abstract_matcher"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classreflex_1_1_abstract_matcher')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classreflex_1_1_abstract_matcher.html">reflex::AbstractMatcher</a></td></tr>
<tr class="memitem:a82ed7b2c125bd897dea73443d2650ac6 inherit pro_types_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a82ed7b2c125bd897dea73443d2650ac6">Method</a></td></tr>
<tr class="separator:a82ed7b2c125bd897dea73443d2650ac6 inherit pro_types_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab8a1264b3ede06dbba853b1ca0baead5"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#ab8a1264b3ede06dbba853b1ca0baead5">match</a> (<a class="el" href="classreflex_1_1_abstract_matcher.html#a82ed7b2c125bd897dea73443d2650ac6">Method</a> method)</td></tr>
<tr class="memdesc:ab8a1264b3ede06dbba853b1ca0baead5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if input matched the pattern using method <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a57efdf6e79f50205036bc4d55e9908e7" title="AbstractMatcher::match method is to scan input (tokenizer) ">Const::SCAN</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#af03daba13cf299ee0e6be2e37ebe59b7" title="AbstractMatcher::match method is to find pattern in input. ">Const::FIND</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a48f6d3e22c2f018fef95b2367a2a9aa4" title="AbstractMatcher::match method is to split input at pattern matches. ">Const::SPLIT</a>, or <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#aa1fe9eb434ef5ff539b01a601977f9ee" title="AbstractMatcher::match method is to match the entire input. ">Const::MATCH</a>.  <a href="#ab8a1264b3ede06dbba853b1ca0baead5">More...</a><br /></td></tr>
<tr class="separator:ab8a1264b3ede06dbba853b1ca0baead5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239f292c95cb04fba2ee063f000b270f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a239f292c95cb04fba2ee063f000b270f">advance</a> ()</td></tr>
<tr class="memdesc:a239f292c95cb04fba2ee063f000b270f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if able to advance to next possible match.  <a href="#a239f292c95cb04fba2ee063f000b270f">More...</a><br /></td></tr>
<tr class="separator:a239f292c95cb04fba2ee063f000b270f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9219c4d9993612e8afe8d9d97af234a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#ac9219c4d9993612e8afe8d9d97af234a">newline</a> ()</td></tr>
<tr class="memdesc:ac9219c4d9993612e8afe8d9d97af234a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update indentation column counter for <a class="el" href="classreflex_1_1_matcher.html#a505a765341793c9d4b0cbbe833920e93" title="Returns true if looking at indent. ">indent()</a> and <a class="el" href="classreflex_1_1_matcher.html#a05ff32e0519d3af80d376b51c561d71e" title="Returns true if looking at dedent. ">dedent()</a>.  <a href="#ac9219c4d9993612e8afe8d9d97af234a">More...</a><br /></td></tr>
<tr class="separator:ac9219c4d9993612e8afe8d9d97af234a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505a765341793c9d4b0cbbe833920e93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a505a765341793c9d4b0cbbe833920e93">indent</a> ()</td></tr>
<tr class="memdesc:a505a765341793c9d4b0cbbe833920e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if looking at indent.  <a href="#a505a765341793c9d4b0cbbe833920e93">More...</a><br /></td></tr>
<tr class="separator:a505a765341793c9d4b0cbbe833920e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ff32e0519d3af80d376b51c561d71e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a05ff32e0519d3af80d376b51c561d71e">dedent</a> ()</td></tr>
<tr class="memdesc:a05ff32e0519d3af80d376b51c561d71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if looking at dedent.  <a href="#a05ff32e0519d3af80d376b51c561d71e">More...</a><br /></td></tr>
<tr class="separator:a05ff32e0519d3af80d376b51c561d71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43df76e4f12a3890d096e9cf476aea03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a43df76e4f12a3890d096e9cf476aea03">boyer_moore_init</a> (const char *pat, size_t len)</td></tr>
<tr class="memdesc:a43df76e4f12a3890d096e9cf476aea03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boyer-Moore preprocessing of the given pattern pat of length len, generates bmd_ &gt; 0 and bms_[] shifts.  <a href="#a43df76e4f12a3890d096e9cf476aea03">More...</a><br /></td></tr>
<tr class="separator:a43df76e4f12a3890d096e9cf476aea03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classreflex_1_1_pattern_matcher"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classreflex_1_1_pattern_matcher')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classreflex_1_1_pattern_matcher.html">reflex::PatternMatcher&lt; reflex::Pattern &gt;</a></td></tr>
<tr class="memitem:ad0e7fa27c5340c1e48416def14f338a4 inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#ad0e7fa27c5340c1e48416def14f338a4">PatternMatcher</a> (const <a class="el" href="classreflex_1_1_pattern_matcher.html#a56c667f62f9d60ccfe3caf16bbc2a9fc">Pattern</a> *<a class="el" href="classreflex_1_1_pattern_matcher.html#a05c456bf148afd72ed92f54434cad16f">pattern</a>=NULL, const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;<a class="el" href="classreflex_1_1_abstract_matcher.html#ab49c7878fc1d7c39e0ca264a5c919f08">input</a>=<a class="el" href="classreflex_1_1_input.html">Input</a>(), const char *opt=NULL)</td></tr>
<tr class="memdesc:ad0e7fa27c5340c1e48416def14f338a4 inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a base abstract matcher from a pointer to a persistent pattern object (that is shared with this class) and an input character sequence.  <a href="#ad0e7fa27c5340c1e48416def14f338a4">More...</a><br /></td></tr>
<tr class="separator:ad0e7fa27c5340c1e48416def14f338a4 inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b34e53c35d6ee5a6e259d2c5ba3bb5c inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a0b34e53c35d6ee5a6e259d2c5ba3bb5c">PatternMatcher</a> (const <a class="el" href="classreflex_1_1_pattern_matcher.html#a56c667f62f9d60ccfe3caf16bbc2a9fc">Pattern</a> &amp;<a class="el" href="classreflex_1_1_pattern_matcher.html#a05c456bf148afd72ed92f54434cad16f">pattern</a>, const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;<a class="el" href="classreflex_1_1_abstract_matcher.html#ab49c7878fc1d7c39e0ca264a5c919f08">input</a>=<a class="el" href="classreflex_1_1_input.html">Input</a>(), const char *opt=NULL)</td></tr>
<tr class="separator:a0b34e53c35d6ee5a6e259d2c5ba3bb5c inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdec87c3a04447b40431e7dc8cbb2b4f inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#abdec87c3a04447b40431e7dc8cbb2b4f">PatternMatcher</a> (const char *<a class="el" href="classreflex_1_1_pattern_matcher.html#a05c456bf148afd72ed92f54434cad16f">pattern</a>, const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;<a class="el" href="classreflex_1_1_abstract_matcher.html#ab49c7878fc1d7c39e0ca264a5c919f08">input</a>=<a class="el" href="classreflex_1_1_input.html">Input</a>(), const char *opt=NULL)</td></tr>
<tr class="memdesc:abdec87c3a04447b40431e7dc8cbb2b4f inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a base abstract matcher from a regex pattern string and an input character sequence.  <a href="#abdec87c3a04447b40431e7dc8cbb2b4f">More...</a><br /></td></tr>
<tr class="separator:abdec87c3a04447b40431e7dc8cbb2b4f inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265a88b2aee5c8f602f02f4f65ec810b inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a265a88b2aee5c8f602f02f4f65ec810b">PatternMatcher</a> (const std::string &amp;<a class="el" href="classreflex_1_1_pattern_matcher.html#a05c456bf148afd72ed92f54434cad16f">pattern</a>, const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;<a class="el" href="classreflex_1_1_abstract_matcher.html#ab49c7878fc1d7c39e0ca264a5c919f08">input</a>=<a class="el" href="classreflex_1_1_input.html">Input</a>(), const char *opt=NULL)</td></tr>
<tr class="memdesc:a265a88b2aee5c8f602f02f4f65ec810b inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a base abstract matcher from a regex pattern string and an input character sequence.  <a href="#a265a88b2aee5c8f602f02f4f65ec810b">More...</a><br /></td></tr>
<tr class="separator:a265a88b2aee5c8f602f02f4f65ec810b inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classreflex_1_1_abstract_matcher"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classreflex_1_1_abstract_matcher')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classreflex_1_1_abstract_matcher.html">reflex::AbstractMatcher</a></td></tr>
<tr class="memitem:afb2962482f26a93cd207a6e8de59da83 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#afb2962482f26a93cd207a6e8de59da83">init</a> (const char *opt=NULL)</td></tr>
<tr class="memdesc:afb2962482f26a93cd207a6e8de59da83 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the base abstract matcher at construction.  <a href="#afb2962482f26a93cd207a6e8de59da83">More...</a><br /></td></tr>
<tr class="separator:afb2962482f26a93cd207a6e8de59da83 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92391ce2c5eab5a6dbce067a8326702e inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a92391ce2c5eab5a6dbce067a8326702e">get</a> (char *s, size_t n)</td></tr>
<tr class="memdesc:a92391ce2c5eab5a6dbce067a8326702e inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns more input directly from the source (method can be overriden, as by reflex::FlexLexer::get(s, n) for example that invokes reflex::FlexLexer::LexerInput(s, n)).  <a href="#a92391ce2c5eab5a6dbce067a8326702e">More...</a><br /></td></tr>
<tr class="separator:a92391ce2c5eab5a6dbce067a8326702e inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046e0696b048d229ea2d77f5010c41e1 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a046e0696b048d229ea2d77f5010c41e1">wrap</a> ()</td></tr>
<tr class="memdesc:a046e0696b048d229ea2d77f5010c41e1 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if wrapping of input after EOF is supported.  <a href="#a046e0696b048d229ea2d77f5010c41e1">More...</a><br /></td></tr>
<tr class="separator:a046e0696b048d229ea2d77f5010c41e1 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450e338dc97b63c595ae3b583ccc9037 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a450e338dc97b63c595ae3b583ccc9037">grow</a> (size_t need=<a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a6f7de58d1118b6f74f117a6b259359be">Const::BLOCK</a>)</td></tr>
<tr class="memdesc:a450e338dc97b63c595ae3b583ccc9037 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift or expand the internal buffer when it is too small to accommodate more input, where the buffer size is doubled when needed.  <a href="#a450e338dc97b63c595ae3b583ccc9037">More...</a><br /></td></tr>
<tr class="separator:a450e338dc97b63c595ae3b583ccc9037 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cea639acc9ea8ff0afba554432ba64 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a33cea639acc9ea8ff0afba554432ba64">get</a> ()</td></tr>
<tr class="memdesc:a33cea639acc9ea8ff0afba554432ba64 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next character read from the current input source.  <a href="#a33cea639acc9ea8ff0afba554432ba64">More...</a><br /></td></tr>
<tr class="separator:a33cea639acc9ea8ff0afba554432ba64 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab09e1287291012d0c7fd05506b69f2 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a6ab09e1287291012d0c7fd05506b69f2">reset_text</a> ()</td></tr>
<tr class="memdesc:a6ab09e1287291012d0c7fd05506b69f2 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the matched text by removing the terminating \0, which is needed to search for a new match.  <a href="#a6ab09e1287291012d0c7fd05506b69f2">More...</a><br /></td></tr>
<tr class="separator:a6ab09e1287291012d0c7fd05506b69f2 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8d28fc8c5326d5f05f84aaa588d564 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a5f8d28fc8c5326d5f05f84aaa588d564">set_current</a> (size_t loc)</td></tr>
<tr class="memdesc:a5f8d28fc8c5326d5f05f84aaa588d564 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current position in the buffer for the next match.  <a href="#a5f8d28fc8c5326d5f05f84aaa588d564">More...</a><br /></td></tr>
<tr class="separator:a5f8d28fc8c5326d5f05f84aaa588d564 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d2f21d13e3ae841277126c5eacb5a8 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a23d2f21d13e3ae841277126c5eacb5a8">set_current_match</a> (size_t loc)</td></tr>
<tr class="memdesc:a23d2f21d13e3ae841277126c5eacb5a8 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current match position in the buffer.  <a href="#a23d2f21d13e3ae841277126c5eacb5a8">More...</a><br /></td></tr>
<tr class="separator:a23d2f21d13e3ae841277126c5eacb5a8 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6889e7a74017302ef588e7371d06e6a inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ad6889e7a74017302ef588e7371d06e6a">get_more</a> ()</td></tr>
<tr class="memdesc:ad6889e7a74017302ef588e7371d06e6a inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next character and grow the buffer to make more room if necessary.  <a href="#ad6889e7a74017302ef588e7371d06e6a">More...</a><br /></td></tr>
<tr class="separator:ad6889e7a74017302ef588e7371d06e6a inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a57145ce5ead569c3758be586d28f41 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7a57145ce5ead569c3758be586d28f41">peek_more</a> ()</td></tr>
<tr class="memdesc:a7a57145ce5ead569c3758be586d28f41 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the next character and grow the buffer to make more room if necessary.  <a href="#a7a57145ce5ead569c3758be586d28f41">More...</a><br /></td></tr>
<tr class="separator:a7a57145ce5ead569c3758be586d28f41 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345dcf64f1671bbb12056408045fa441 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a345dcf64f1671bbb12056408045fa441">update</a> ()</td></tr>
<tr class="memdesc:a345dcf64f1671bbb12056408045fa441 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the newline count, column count, and character count when shifting the buffer.  <a href="#a345dcf64f1671bbb12056408045fa441">More...</a><br /></td></tr>
<tr class="separator:a345dcf64f1671bbb12056408045fa441 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a3dcae088c372c3fcc3eda9f89daf34d1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a3dcae088c372c3fcc3eda9f89daf34d1">predict_match</a> (const <a class="el" href="classreflex_1_1_pattern.html#afc0939fcf3c55e813039bc3e475a8a51">Pattern::Pred</a> pmh[], const char *s, size_t n)</td></tr>
<tr class="memdesc:a3dcae088c372c3fcc3eda9f89daf34d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when match is predicted, based on s[0..3..e-1] (e &gt;= s + 4).  <a href="#a3dcae088c372c3fcc3eda9f89daf34d1">More...</a><br /></td></tr>
<tr class="separator:a3dcae088c372c3fcc3eda9f89daf34d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db4e385bc60d761212d5795edbec73b"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a3db4e385bc60d761212d5795edbec73b">predict_match</a> (const <a class="el" href="classreflex_1_1_pattern.html#afc0939fcf3c55e813039bc3e475a8a51">Pattern::Pred</a> pma[], const char *s)</td></tr>
<tr class="memdesc:a3db4e385bc60d761212d5795edbec73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns zero when match is predicted or nonzero shift value, based on s[0..3].  <a href="#a3db4e385bc60d761212d5795edbec73b">More...</a><br /></td></tr>
<tr class="separator:a3db4e385bc60d761212d5795edbec73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3b760391b7b16eed637ada38430d97e1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a3b760391b7b16eed637ada38430d97e1">ded_</a></td></tr>
<tr class="memdesc:a3b760391b7b16eed637ada38430d97e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">dedent count  <a href="#a3b760391b7b16eed637ada38430d97e1">More...</a><br /></td></tr>
<tr class="separator:a3b760391b7b16eed637ada38430d97e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70416fa24e74e321ae89d750b720945"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#ad70416fa24e74e321ae89d750b720945">col_</a></td></tr>
<tr class="memdesc:ad70416fa24e74e321ae89d750b720945"><td class="mdescLeft">&#160;</td><td class="mdescRight">column counter for indent matching, updated by <a class="el" href="classreflex_1_1_matcher.html#ac9219c4d9993612e8afe8d9d97af234a" title="Update indentation column counter for indent() and dedent(). ">newline()</a>, <a class="el" href="classreflex_1_1_matcher.html#a505a765341793c9d4b0cbbe833920e93" title="Returns true if looking at indent. ">indent()</a>, and <a class="el" href="classreflex_1_1_matcher.html#a05ff32e0519d3af80d376b51c561d71e" title="Returns true if looking at dedent. ">dedent()</a>  <a href="#ad70416fa24e74e321ae89d750b720945">More...</a><br /></td></tr>
<tr class="separator:ad70416fa24e74e321ae89d750b720945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414c28bfea74537044bee654cb413820"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_matcher.html#a9748ab7e9dc48d3893968f432a3f7cfa">Stops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a414c28bfea74537044bee654cb413820">tab_</a></td></tr>
<tr class="memdesc:a414c28bfea74537044bee654cb413820"><td class="mdescLeft">&#160;</td><td class="mdescRight">tab stops set by detecting indent margins  <a href="#a414c28bfea74537044bee654cb413820">More...</a><br /></td></tr>
<tr class="separator:a414c28bfea74537044bee654cb413820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31187ae9febac87f463145c18d248476"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a31187ae9febac87f463145c18d248476">lap_</a></td></tr>
<tr class="memdesc:a31187ae9febac87f463145c18d248476"><td class="mdescLeft">&#160;</td><td class="mdescRight">lookahead position in input that heads a lookahead match (indexed by lookahead number)  <a href="#a31187ae9febac87f463145c18d248476">More...</a><br /></td></tr>
<tr class="separator:a31187ae9febac87f463145c18d248476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfeefc270fb9f89da7122f1cea86872c"><td class="memItemLeft" align="right" valign="top">std::stack&lt; <a class="el" href="classreflex_1_1_matcher.html#a9748ab7e9dc48d3893968f432a3f7cfa">Stops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#adfeefc270fb9f89da7122f1cea86872c">stk_</a></td></tr>
<tr class="memdesc:adfeefc270fb9f89da7122f1cea86872c"><td class="mdescLeft">&#160;</td><td class="mdescRight">stack to push/pop stops  <a href="#adfeefc270fb9f89da7122f1cea86872c">More...</a><br /></td></tr>
<tr class="separator:adfeefc270fb9f89da7122f1cea86872c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619a527eb79b444fba089a33fb1fdd33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html">FSM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a619a527eb79b444fba089a33fb1fdd33">fsm_</a></td></tr>
<tr class="memdesc:a619a527eb79b444fba089a33fb1fdd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">local state for <a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code  <a href="#a619a527eb79b444fba089a33fb1fdd33">More...</a><br /></td></tr>
<tr class="separator:a619a527eb79b444fba089a33fb1fdd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e7979b2b89ac05ca4deb937a2f3d97"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a47e7979b2b89ac05ca4deb937a2f3d97">bmd_</a></td></tr>
<tr class="memdesc:a47e7979b2b89ac05ca4deb937a2f3d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boyer-Moore-Horspool jump distance on mismatch, B-M-H is enabled when &gt; 0.  <a href="#a47e7979b2b89ac05ca4deb937a2f3d97">More...</a><br /></td></tr>
<tr class="separator:a47e7979b2b89ac05ca4deb937a2f3d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7207b196024ffe415ce537d6e551b25"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#ae7207b196024ffe415ce537d6e551b25">bms_</a> [256]</td></tr>
<tr class="memdesc:ae7207b196024ffe415ce537d6e551b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boyer-Moore-Horspool skip array.  <a href="#ae7207b196024ffe415ce537d6e551b25">More...</a><br /></td></tr>
<tr class="separator:ae7207b196024ffe415ce537d6e551b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa9c9a4917bdbb24b359d3eaa9185b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a8fa9c9a4917bdbb24b359d3eaa9185b4">mrk_</a></td></tr>
<tr class="memdesc:a8fa9c9a4917bdbb24b359d3eaa9185b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">indent  or dedent  in pattern found: should check and update indent stops  <a href="#a8fa9c9a4917bdbb24b359d3eaa9185b4">More...</a><br /></td></tr>
<tr class="separator:a8fa9c9a4917bdbb24b359d3eaa9185b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classreflex_1_1_pattern_matcher"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classreflex_1_1_pattern_matcher')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classreflex_1_1_pattern_matcher.html">reflex::PatternMatcher&lt; reflex::Pattern &gt;</a></td></tr>
<tr class="memitem:a2dced0fc17ca335ce91a77ac1698e620 inherit pro_attribs_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classreflex_1_1_pattern_matcher.html#a56c667f62f9d60ccfe3caf16bbc2a9fc">Pattern</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a2dced0fc17ca335ce91a77ac1698e620">pat_</a></td></tr>
<tr class="memdesc:a2dced0fc17ca335ce91a77ac1698e620 inherit pro_attribs_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">points to the pattern object used by the matcher  <a href="#a2dced0fc17ca335ce91a77ac1698e620">More...</a><br /></td></tr>
<tr class="separator:a2dced0fc17ca335ce91a77ac1698e620 inherit pro_attribs_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609bef4919413b1448f4db3d4a1d0fd4 inherit pro_attribs_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a609bef4919413b1448f4db3d4a1d0fd4">own_</a></td></tr>
<tr class="memdesc:a609bef4919413b1448f4db3d4a1d0fd4 inherit pro_attribs_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if PatternMatcher::pat_ was allocated and should be deleted  <a href="#a609bef4919413b1448f4db3d4a1d0fd4">More...</a><br /></td></tr>
<tr class="separator:a609bef4919413b1448f4db3d4a1d0fd4 inherit pro_attribs_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classreflex_1_1_abstract_matcher"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classreflex_1_1_abstract_matcher')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classreflex_1_1_abstract_matcher.html">reflex::AbstractMatcher</a></td></tr>
<tr class="memitem:a7d944c389bc36abb15ba6c9f0601ab1b inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_option.html">Option</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7d944c389bc36abb15ba6c9f0601ab1b">opt_</a></td></tr>
<tr class="memdesc:a7d944c389bc36abb15ba6c9f0601ab1b inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">options for matcher engines  <a href="#a7d944c389bc36abb15ba6c9f0601ab1b">More...</a><br /></td></tr>
<tr class="separator:a7d944c389bc36abb15ba6c9f0601ab1b inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522144cc1e11d86a7a44f3f41acc4ba9 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9">buf_</a></td></tr>
<tr class="memdesc:a522144cc1e11d86a7a44f3f41acc4ba9 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">input character sequence buffer  <a href="#a522144cc1e11d86a7a44f3f41acc4ba9">More...</a><br /></td></tr>
<tr class="separator:a522144cc1e11d86a7a44f3f41acc4ba9 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce676b26fd73f76186ed5cfb4a9b9dc inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a6ce676b26fd73f76186ed5cfb4a9b9dc">txt_</a></td></tr>
<tr class="memdesc:a6ce676b26fd73f76186ed5cfb4a9b9dc inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">points to the matched text in buffer <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a>  <a href="#a6ce676b26fd73f76186ed5cfb4a9b9dc">More...</a><br /></td></tr>
<tr class="separator:a6ce676b26fd73f76186ed5cfb4a9b9dc inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c1bbabe9a7e0dd1a8b43b9bce58dfc inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a63c1bbabe9a7e0dd1a8b43b9bce58dfc">len_</a></td></tr>
<tr class="memdesc:a63c1bbabe9a7e0dd1a8b43b9bce58dfc inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of the matched text  <a href="#a63c1bbabe9a7e0dd1a8b43b9bce58dfc">More...</a><br /></td></tr>
<tr class="separator:a63c1bbabe9a7e0dd1a8b43b9bce58dfc inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc1bd57b738b0eb3320a1861312d78e inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7dc1bd57b738b0eb3320a1861312d78e">cap_</a></td></tr>
<tr class="memdesc:a7dc1bd57b738b0eb3320a1861312d78e inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">nonzero capture index of an accepted match or zero  <a href="#a7dc1bd57b738b0eb3320a1861312d78e">More...</a><br /></td></tr>
<tr class="separator:a7dc1bd57b738b0eb3320a1861312d78e inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d1bb45408688e9fe41050363a2240c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a19d1bb45408688e9fe41050363a2240c">cur_</a></td></tr>
<tr class="memdesc:a19d1bb45408688e9fe41050363a2240c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">next position in <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a> to assign to <a class="el" href="classreflex_1_1_abstract_matcher.html#a6ce676b26fd73f76186ed5cfb4a9b9dc" title="points to the matched text in buffer AbstractMatcher::buf_ ">AbstractMatcher::txt_</a>  <a href="#a19d1bb45408688e9fe41050363a2240c">More...</a><br /></td></tr>
<tr class="separator:a19d1bb45408688e9fe41050363a2240c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028118ceb0a16e9ee12cfb74d7141689 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a028118ceb0a16e9ee12cfb74d7141689">pos_</a></td></tr>
<tr class="memdesc:a028118ceb0a16e9ee12cfb74d7141689 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">position in <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a> after <a class="el" href="classreflex_1_1_abstract_matcher.html#a6ce676b26fd73f76186ed5cfb4a9b9dc" title="points to the matched text in buffer AbstractMatcher::buf_ ">AbstractMatcher::txt_</a>  <a href="#a028118ceb0a16e9ee12cfb74d7141689">More...</a><br /></td></tr>
<tr class="separator:a028118ceb0a16e9ee12cfb74d7141689 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5567cb2217e7d76122b4a7332cf12215 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a5567cb2217e7d76122b4a7332cf12215">end_</a></td></tr>
<tr class="memdesc:a5567cb2217e7d76122b4a7332cf12215 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">ending position of the input buffered in <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a>  <a href="#a5567cb2217e7d76122b4a7332cf12215">More...</a><br /></td></tr>
<tr class="separator:a5567cb2217e7d76122b4a7332cf12215 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3372a98e775f5dd2d816d4f8dacf78 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a8c3372a98e775f5dd2d816d4f8dacf78">max_</a></td></tr>
<tr class="memdesc:a8c3372a98e775f5dd2d816d4f8dacf78 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">total buffer size and max position + 1 to fill  <a href="#a8c3372a98e775f5dd2d816d4f8dacf78">More...</a><br /></td></tr>
<tr class="separator:a8c3372a98e775f5dd2d816d4f8dacf78 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0eb104096b1e02b78420bb02c89896c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ab0eb104096b1e02b78420bb02c89896c">ind_</a></td></tr>
<tr class="memdesc:ab0eb104096b1e02b78420bb02c89896c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">current indent position  <a href="#ab0eb104096b1e02b78420bb02c89896c">More...</a><br /></td></tr>
<tr class="separator:ab0eb104096b1e02b78420bb02c89896c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e77a5e960482ff2ee1bb89e3c06c5eb inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a6e77a5e960482ff2ee1bb89e3c06c5eb">blk_</a></td></tr>
<tr class="memdesc:a6e77a5e960482ff2ee1bb89e3c06c5eb inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">block size for block-based input reading, as set by <a class="el" href="classreflex_1_1_abstract_matcher.html#a0fb96965d228951194f0a2b9ee574dcf" title="Set buffer block size for reading: use 1 for interactive input, 0 (or omit argument) to buffer all in...">AbstractMatcher::buffer</a>  <a href="#a6e77a5e960482ff2ee1bb89e3c06c5eb">More...</a><br /></td></tr>
<tr class="separator:a6e77a5e960482ff2ee1bb89e3c06c5eb inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e3fb0e851b132fd1e902de9ab56dba inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a15e3fb0e851b132fd1e902de9ab56dba">got_</a></td></tr>
<tr class="memdesc:a15e3fb0e851b132fd1e902de9ab56dba inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">last unsigned character we looked at (to determine anchors and boundaries)  <a href="#a15e3fb0e851b132fd1e902de9ab56dba">More...</a><br /></td></tr>
<tr class="separator:a15e3fb0e851b132fd1e902de9ab56dba inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae712053969ae8fadeee28c1e08421cf5 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ae712053969ae8fadeee28c1e08421cf5">chr_</a></td></tr>
<tr class="memdesc:ae712053969ae8fadeee28c1e08421cf5 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">the character located at <a class="el" href="classreflex_1_1_abstract_matcher.html#a6ce676b26fd73f76186ed5cfb4a9b9dc" title="points to the matched text in buffer AbstractMatcher::buf_ ">AbstractMatcher::txt_</a>[<a class="el" href="classreflex_1_1_abstract_matcher.html#a63c1bbabe9a7e0dd1a8b43b9bce58dfc" title="size of the matched text ">AbstractMatcher::len_</a>]  <a href="#ae712053969ae8fadeee28c1e08421cf5">More...</a><br /></td></tr>
<tr class="separator:ae712053969ae8fadeee28c1e08421cf5 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53795b9e0e5dd91b6016ebb4fa2cc4dd inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a53795b9e0e5dd91b6016ebb4fa2cc4dd">lpb_</a></td></tr>
<tr class="memdesc:a53795b9e0e5dd91b6016ebb4fa2cc4dd inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">line pointer in buffer, updated when counting line numbers with <a class="el" href="classreflex_1_1_abstract_matcher.html#a3bbfcc6386048d9c3613f7de919ba242" title="Updates and returns the starting line number of the match in the input character sequence. ">lineno()</a>  <a href="#a53795b9e0e5dd91b6016ebb4fa2cc4dd">More...</a><br /></td></tr>
<tr class="separator:a53795b9e0e5dd91b6016ebb4fa2cc4dd inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad237874fc8405e2f701765de41d6cd37 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ad237874fc8405e2f701765de41d6cd37">lno_</a></td></tr>
<tr class="memdesc:ad237874fc8405e2f701765de41d6cd37 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">line number count (cached)  <a href="#ad237874fc8405e2f701765de41d6cd37">More...</a><br /></td></tr>
<tr class="separator:ad237874fc8405e2f701765de41d6cd37 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d20b0cfaa79571f201b52289c3fe2c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a92d20b0cfaa79571f201b52289c3fe2c">cno_</a></td></tr>
<tr class="memdesc:a92d20b0cfaa79571f201b52289c3fe2c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">column number count (cached)  <a href="#a92d20b0cfaa79571f201b52289c3fe2c">More...</a><br /></td></tr>
<tr class="separator:a92d20b0cfaa79571f201b52289c3fe2c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf059b818f76cda98cfd8ef059d8586e inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#acf059b818f76cda98cfd8ef059d8586e">num_</a></td></tr>
<tr class="memdesc:acf059b818f76cda98cfd8ef059d8586e inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">character count (number of characters flushed prior to this buffered input)  <a href="#acf059b818f76cda98cfd8ef059d8586e">More...</a><br /></td></tr>
<tr class="separator:acf059b818f76cda98cfd8ef059d8586e inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b02b00048ab1b2bbb2b548f8b7aa02 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a62b02b00048ab1b2bbb2b548f8b7aa02">own_</a></td></tr>
<tr class="memdesc:a62b02b00048ab1b2bbb2b548f8b7aa02 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a> was allocated and should be deleted  <a href="#a62b02b00048ab1b2bbb2b548f8b7aa02">More...</a><br /></td></tr>
<tr class="separator:a62b02b00048ab1b2bbb2b548f8b7aa02 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbc10723ccc884bb90ed85a0dbdaabd inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a2bbc10723ccc884bb90ed85a0dbdaabd">eof_</a></td></tr>
<tr class="memdesc:a2bbc10723ccc884bb90ed85a0dbdaabd inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">input has reached EOF  <a href="#a2bbc10723ccc884bb90ed85a0dbdaabd">More...</a><br /></td></tr>
<tr class="separator:a2bbc10723ccc884bb90ed85a0dbdaabd inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdfd4999a13a782643d33da7bd2b5cf inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a4fdfd4999a13a782643d33da7bd2b5cf">mat_</a></td></tr>
<tr class="memdesc:a4fdfd4999a13a782643d33da7bd2b5cf inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if <a class="el" href="classreflex_1_1_abstract_matcher.html#ab880e6c8fe0df7c4ee7bb629aab41d0f" title="Returns nonzero capture index (i.e. true) if the entire input matches this matcher&#39;s pattern (and int...">AbstractMatcher::matches()</a> was successful  <a href="#a4fdfd4999a13a782643d33da7bd2b5cf">More...</a><br /></td></tr>
<tr class="separator:a4fdfd4999a13a782643d33da7bd2b5cf inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classreflex_1_1_pattern_matcher"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classreflex_1_1_pattern_matcher')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classreflex_1_1_pattern_matcher.html">reflex::PatternMatcher&lt; reflex::Pattern &gt;</a></td></tr>
<tr class="memitem:a56c667f62f9d60ccfe3caf16bbc2a9fc inherit pub_types_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classreflex_1_1_pattern.html">reflex::Pattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a56c667f62f9d60ccfe3caf16bbc2a9fc">Pattern</a></td></tr>
<tr class="separator:a56c667f62f9d60ccfe3caf16bbc2a9fc inherit pub_types_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classreflex_1_1_abstract_matcher"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classreflex_1_1_abstract_matcher')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classreflex_1_1_abstract_matcher.html">reflex::AbstractMatcher</a></td></tr>
<tr class="memitem:a7237c1fb8ab2a2283117739e6516c31f inherit pub_types_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classreflex_1_1_abstract_matcher_1_1_iterator.html">AbstractMatcher::Iterator</a>&lt; <a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7237c1fb8ab2a2283117739e6516c31f">iterator</a></td></tr>
<tr class="memdesc:a7237c1fb8ab2a2283117739e6516c31f inherit pub_types_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::input_iterator for scanning, searching, and splitting input character sequences  <a href="#a7237c1fb8ab2a2283117739e6516c31f">More...</a><br /></td></tr>
<tr class="separator:a7237c1fb8ab2a2283117739e6516c31f inherit pub_types_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24336f3d3f122aa0e904fc18954943f8 inherit pub_types_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classreflex_1_1_abstract_matcher_1_1_iterator.html">AbstractMatcher::Iterator</a>&lt; const <a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a24336f3d3f122aa0e904fc18954943f8">const_iterator</a></td></tr>
<tr class="separator:a24336f3d3f122aa0e904fc18954943f8 inherit pub_types_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classreflex_1_1_abstract_matcher"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classreflex_1_1_abstract_matcher')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classreflex_1_1_abstract_matcher.html">reflex::AbstractMatcher</a></td></tr>
<tr class="memitem:a489c6327fb6521cc722852ada690f5ca inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html">Operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a489c6327fb6521cc722852ada690f5ca">scan</a></td></tr>
<tr class="memdesc:a489c6327fb6521cc722852ada690f5ca inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">functor to scan input (to tokenize input)  <a href="#a489c6327fb6521cc722852ada690f5ca">More...</a><br /></td></tr>
<tr class="separator:a489c6327fb6521cc722852ada690f5ca inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec40e4c9070975bcafa94af5db0e514 inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html">Operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a3ec40e4c9070975bcafa94af5db0e514">find</a></td></tr>
<tr class="memdesc:a3ec40e4c9070975bcafa94af5db0e514 inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">functor to search input  <a href="#a3ec40e4c9070975bcafa94af5db0e514">More...</a><br /></td></tr>
<tr class="separator:a3ec40e4c9070975bcafa94af5db0e514 inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d0cb13c2dca93cc556c06c24633b8d inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html">Operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a16d0cb13c2dca93cc556c06c24633b8d">split</a></td></tr>
<tr class="memdesc:a16d0cb13c2dca93cc556c06c24633b8d inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">functor to split input  <a href="#a16d0cb13c2dca93cc556c06c24633b8d">More...</a><br /></td></tr>
<tr class="separator:a16d0cb13c2dca93cc556c06c24633b8d inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e1dd16b4c2deca18d9093fc727ee3b inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html">Input</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ae4e1dd16b4c2deca18d9093fc727ee3b">in</a></td></tr>
<tr class="memdesc:ae4e1dd16b4c2deca18d9093fc727ee3b inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">input character sequence being matched by this matcher  <a href="#ae4e1dd16b4c2deca18d9093fc727ee3b">More...</a><br /></td></tr>
<tr class="separator:ae4e1dd16b4c2deca18d9093fc727ee3b inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RE/flex matcher engine class, implements <a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a> pattern matching interface with scan, find, split functors and iterators. </p>
<p>More info TODO </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a9748ab7e9dc48d3893968f432a3f7cfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;size_t&gt; <a class="el" href="classreflex_1_1_matcher.html#a9748ab7e9dc48d3893968f432a3f7cfa">reflex::Matcher::Stops</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>indent margin/tab stops </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acad91a095aa3a8e77da5d770a3c9561a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Matcher::Matcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="a385c902b36f97ca11c4e46053da8dca2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Matcher::Matcher </td>
          <td>(</td>
          <td class="paramtype">const P *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em> = <code><a class="el" href="classreflex_1_1_input.html">Input</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>opt</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct matcher engine from a pattern or a string regex, and an input character sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">&lt;P&gt;</td><td>a <a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a> or a string regex </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>points to a <a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a> or a string regex for this matcher </td></tr>
    <tr><td class="paramname">input</td><td>input character sequence for this matcher </td></tr>
    <tr><td class="paramname">opt</td><td>option string of the form <code>(A|N|T(=[[:digit:]])?|;)*</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16be665aca5108271f92f38e6cb4bd58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Matcher::Matcher </td>
          <td>(</td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em> = <code><a class="el" href="classreflex_1_1_input.html">Input</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>opt</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct matcher engine from a pattern or a string regex, and an input character sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">&lt;P&gt;</td><td>a <a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a> or a string regex </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>a <a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a> or a string regex for this matcher </td></tr>
    <tr><td class="paramname">input</td><td>input character sequence for this matcher </td></tr>
    <tr><td class="paramname">opt</td><td>option string of the form <code>(A|N|T(=[[:digit:]])?|;)*</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed0ce297787f4417b00e8f0b6e325e47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Matcher::Matcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_matcher.html">Matcher</a> &amp;&#160;</td>
          <td class="paramname"><em>matcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matcher</td><td>matcher to copy with pattern (pattern may be shared) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a239f292c95cb04fba2ee063f000b270f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::advance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if able to advance to next possible match. </p>
<dl class="section return"><dt>Returns</dt><dd>true if possible match found </dd></dl>

</div>
</div>
<a class="anchor" id="a43df76e4f12a3890d096e9cf476aea03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::boyer_moore_init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boyer-Moore preprocessing of the given pattern pat of length len, generates bmd_ &gt; 0 and bms_[] shifts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pat</td><td>pattern string </td></tr>
    <tr><td class="paramname">len</td><td>nonzero length of the pattern string, should be less than 256 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06cc1f381a99c834a0abf213b617b895"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::clear_stops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear indent stop positions. </p>

</div>
</div>
<a class="anchor" id="a70d0469bd7c8ad7697dc877d4d30b8b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classreflex_1_1_matcher.html">Matcher</a>* reflex::Matcher::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymorphic cloning. </p>

<p>Implements <a class="el" href="classreflex_1_1_abstract_matcher.html#a990b0f98e3b73ae3a2f4a9aa91626b8d">reflex::AbstractMatcher</a>.</p>

</div>
</div>
<a class="anchor" id="a8862686f6d5680d4d0e5af146c4aed69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string reflex::Matcher::convert </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>regex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacereflex.html#ab659f1b759d66631c2e2e32771af1200">convert_flag_type</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespacereflex_1_1convert__flag.html#af5c6fe22fc79bb893e135d583d525930">convert_flag::none</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a regex to an acceptable form, given the specified regex library signature <code>"[decls:]escapes[?+]"</code>, see <a class="el" href="namespacereflex.html#a4f388dfde137fe178705346b44c56223" title="Returns the converted regex string given a regex library signature and conversion flags...">reflex::convert</a>. </p>

</div>
</div>
<a class="anchor" id="a05ff32e0519d3af80d376b51c561d71e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::dedent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if looking at dedent. </p>
<dl class="section return"><dt>Returns</dt><dd>true if dedent. </dd></dl>

</div>
</div>
<a class="anchor" id="a25e197a62083648d93f813a00131f5b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::delete_stop </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all stop positions from position n and up until the last. </p>

</div>
</div>
<a class="anchor" id="a2e077964c3a6847b1087bed1eb77bc26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_BACK </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> extra code BACK position to a previous position returned by <a class="el" href="classreflex_1_1_matcher.html#a996f60e73e31c802fac029eadac0d149" title="FSM extra code POSN returns current position. ">FSM_POSN()</a>. </p>

</div>
</div>
<a class="anchor" id="ae2d2cbadbfa26b8b49509733971d1cc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int reflex::Matcher::FSM_CHAR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code CHAR. </p>

</div>
</div>
<a class="anchor" id="ae6d846e6b7fe4a8257ead872cd89515a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_DENT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code DENT. </p>

</div>
</div>
<a class="anchor" id="a8a8c67260251d2543772fb4f04d99b9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_FIND </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code FIND,. </p>

</div>
</div>
<a class="anchor" id="a16876012f70f8957f689b9bda076a730"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_HALT </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code HALT. </p>

</div>
</div>
<a class="anchor" id="abaf6459dd5e3c961efae5285ae1e3ad4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_HEAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_pattern.html#a38d69acf1e472d48225a3ba50b138e02">Pattern::Index</a>&#160;</td>
          <td class="paramname"><em>la</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code HEAD. </p>

</div>
</div>
<a class="anchor" id="a81899695d5bb82e06e49608ed9ebd629"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_INIT </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>c1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code INIT,. </p>

</div>
</div>
<a class="anchor" id="a852ba4d4ec243d088a1a052cab98d5b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_BOB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META BOB. </p>

</div>
</div>
<a class="anchor" id="a1d619b6c0e42eef76e82cddea2cc8a34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_BOL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META BOL. </p>

</div>
</div>
<a class="anchor" id="a1df3cef14e6011ae629e7382a87b8e2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_BWB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META BWB. </p>

</div>
</div>
<a class="anchor" id="ade19817779426782ab997a7a5d8e2e3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_BWE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META BWE. </p>

</div>
</div>
<a class="anchor" id="a441387325bdc654d53e95dafd076331c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_DED </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META DED. </p>

</div>
</div>
<a class="anchor" id="a7acbb9557977ccf9a85f6baedc63287f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_EOB </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META EOB. </p>

</div>
</div>
<a class="anchor" id="a0222ac0b08f7dfe4232cc1ae38ec86b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_EOL </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META EOL. </p>

</div>
</div>
<a class="anchor" id="acbe8cafe20bb1a1ee964b04ce7be08e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_EWB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META EWB. </p>

</div>
</div>
<a class="anchor" id="a108d0fa7893bd165a1103aca4e8708ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_EWE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META EWE. </p>

</div>
</div>
<a class="anchor" id="a920ae1d0113ba546efa140f445d18a1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_IND </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META IND. </p>

</div>
</div>
<a class="anchor" id="a3da6f6a08905ca89a5920ccd16d098dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_NWB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META NWB. </p>

</div>
</div>
<a class="anchor" id="a77fbd40b1c0fc532f3ec5dda683d5d86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_NWE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META NWE. </p>

</div>
</div>
<a class="anchor" id="a10ed3182e3f97782b8d4bb9fd090c4bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_UND </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META UND. </p>

</div>
</div>
<a class="anchor" id="a996f60e73e31c802fac029eadac0d149"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Matcher::FSM_POSN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> extra code POSN returns current position. </p>

</div>
</div>
<a class="anchor" id="a899420f3b5924b6c858a862d1c3b5b71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_REDO </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code REDO. </p>

</div>
</div>
<a class="anchor" id="a29425e4f07a84ed574e99e034891493d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_REDO </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code REDO. </p>

</div>
</div>
<a class="anchor" id="a05bf4f34f39a43143b0942dc053c8718"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_TAIL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_pattern.html#a38d69acf1e472d48225a3ba50b138e02">Pattern::Index</a>&#160;</td>
          <td class="paramname"><em>la</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code TAIL. </p>

</div>
</div>
<a class="anchor" id="a6237f5989d641c75edc310beb73fd84d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_TAKE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_pattern.html#a38d69acf1e472d48225a3ba50b138e02">Pattern::Index</a>&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code TAKE. </p>

</div>
</div>
<a class="anchor" id="a1a041cea3bd793a450445cc82b24fc90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_TAKE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_pattern.html#a38d69acf1e472d48225a3ba50b138e02">Pattern::Index</a>&#160;</td>
          <td class="paramname"><em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code TAKE. </p>

</div>
</div>
<a class="anchor" id="a505a765341793c9d4b0cbbe833920e93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::indent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if looking at indent. </p>
<dl class="section return"><dt>Returns</dt><dd>true if indent. </dd></dl>

</div>
</div>
<a class="anchor" id="a06e6875f27734e64531a0e03b0521186"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::insert_stop </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts or appends an indent stop position, keeping indent stops sorted. </p>

</div>
</div>
<a class="anchor" id="a9a835fa7ced2659ece33c458f21b1762"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Matcher::last_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of the last indent stop. </p>

</div>
</div>
<a class="anchor" id="ab8a1264b3ede06dbba853b1ca0baead5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t reflex::Matcher::match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_abstract_matcher.html#a82ed7b2c125bd897dea73443d2650ac6">Method</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if input matched the pattern using method <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a57efdf6e79f50205036bc4d55e9908e7" title="AbstractMatcher::match method is to scan input (tokenizer) ">Const::SCAN</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#af03daba13cf299ee0e6be2e37ebe59b7" title="AbstractMatcher::match method is to find pattern in input. ">Const::FIND</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a48f6d3e22c2f018fef95b2367a2a9aa4" title="AbstractMatcher::match method is to split input at pattern matches. ">Const::SPLIT</a>, or <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#aa1fe9eb434ef5ff539b01a601977f9ee" title="AbstractMatcher::match method is to match the entire input. ">Const::MATCH</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>nonzero if input matched the pattern. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td><a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a57efdf6e79f50205036bc4d55e9908e7" title="AbstractMatcher::match method is to scan input (tokenizer) ">Const::SCAN</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#af03daba13cf299ee0e6be2e37ebe59b7" title="AbstractMatcher::match method is to find pattern in input. ">Const::FIND</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a48f6d3e22c2f018fef95b2367a2a9aa4" title="AbstractMatcher::match method is to split input at pattern matches. ">Const::SPLIT</a>, or <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#aa1fe9eb434ef5ff539b01a601977f9ee" title="AbstractMatcher::match method is to match the entire input. ">Const::MATCH</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classreflex_1_1_abstract_matcher.html#aa3276cec0bb2daba22261e8aec147669">reflex::AbstractMatcher</a>.</p>

</div>
</div>
<a class="anchor" id="ac9219c4d9993612e8afe8d9d97af234a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::newline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update indentation column counter for <a class="el" href="classreflex_1_1_matcher.html#a505a765341793c9d4b0cbbe833920e93" title="Returns true if looking at indent. ">indent()</a> and <a class="el" href="classreflex_1_1_matcher.html#a05ff32e0519d3af80d376b51c561d71e" title="Returns true if looking at dedent. ">dedent()</a>. </p>

</div>
</div>
<a class="anchor" id="acf0031339b3f8426b730a6860e5feba2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;const char*,size_t&gt; reflex::Matcher::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns captured text as a std::pair&lt;const char*,size_t&gt; with string pointer (non-0-terminated) and length. </p>
<dl class="section return"><dt>Returns</dt><dd>std::pair of string pointer and length in the captured text, where [0] returns std::pair(<a class="el" href="classreflex_1_1_abstract_matcher.html#a329001b2880a756dd4d6f6fd0192d004" title="Returns pointer to the begin of the matched text (non-0-terminated), a constant-time operation...">begin()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#adb5fec59e6c6a86b8cf405c40f93d1de" title="Returns the length of the matched text in number of bytes, including matched \0s, a constant-time ope...">size()</a>). </dd></dl>

<p>Implements <a class="el" href="classreflex_1_1_abstract_matcher.html#a99e23c24c8e576f4f6463eda78539d05">reflex::AbstractMatcher</a>.</p>

</div>
</div>
<a class="anchor" id="a363f0c0c37cbb496849034b1542e4344"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::pop_stops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop indent stops. </p>

</div>
</div>
<a class="anchor" id="a3dcae088c372c3fcc3eda9f89daf34d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool reflex::Matcher::predict_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_pattern.html#afc0939fcf3c55e813039bc3e475a8a51">Pattern::Pred</a>&#160;</td>
          <td class="paramname"><em>pmh</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true when match is predicted, based on s[0..3..e-1] (e &gt;= s + 4). </p>

</div>
</div>
<a class="anchor" id="a3db4e385bc60d761212d5795edbec73b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t reflex::Matcher::predict_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_pattern.html#afc0939fcf3c55e813039bc3e475a8a51">Pattern::Pred</a>&#160;</td>
          <td class="paramname"><em>pma</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns zero when match is predicted or nonzero shift value, based on s[0..3]. </p>

</div>
</div>
<a class="anchor" id="addc00e8755eeb766a180943c66786a29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::push_stops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push current indent stops and clear current indent stops. </p>

</div>
</div>
<a class="anchor" id="a641754cf7025a978c7dc672a563ac5c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reflex::Matcher::reset </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>opt</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset this matcher's state to the initial state. </p>

<p>Reimplemented from <a class="el" href="classreflex_1_1_abstract_matcher.html#a66f487ab96e7cef1a66e9780dc45e315">reflex::AbstractMatcher</a>.</p>

</div>
</div>
<a class="anchor" id="adf84adb39572b43c63f56aecd1aaa35d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt;&amp; reflex::Matcher::stops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reference to vector of current indent stop positions. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of size_t. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a47e7979b2b89ac05ca4deb937a2f3d97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Matcher::bmd_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boyer-Moore-Horspool jump distance on mismatch, B-M-H is enabled when &gt; 0. </p>

</div>
</div>
<a class="anchor" id="ae7207b196024ffe415ce537d6e551b25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t reflex::Matcher::bms_[256]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boyer-Moore-Horspool skip array. </p>

</div>
</div>
<a class="anchor" id="ad70416fa24e74e321ae89d750b720945"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Matcher::col_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>column counter for indent matching, updated by <a class="el" href="classreflex_1_1_matcher.html#ac9219c4d9993612e8afe8d9d97af234a" title="Update indentation column counter for indent() and dedent(). ">newline()</a>, <a class="el" href="classreflex_1_1_matcher.html#a505a765341793c9d4b0cbbe833920e93" title="Returns true if looking at indent. ">indent()</a>, and <a class="el" href="classreflex_1_1_matcher.html#a05ff32e0519d3af80d376b51c561d71e" title="Returns true if looking at dedent. ">dedent()</a> </p>

</div>
</div>
<a class="anchor" id="a3b760391b7b16eed637ada38430d97e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Matcher::ded_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dedent count </p>

</div>
</div>
<a class="anchor" id="a619a527eb79b444fba089a33fb1fdd33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html">FSM</a> reflex::Matcher::fsm_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>local state for <a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code </p>

</div>
</div>
<a class="anchor" id="a31187ae9febac87f463145c18d248476"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; reflex::Matcher::lap_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>lookahead position in input that heads a lookahead match (indexed by lookahead number) </p>

</div>
</div>
<a class="anchor" id="a8fa9c9a4917bdbb24b359d3eaa9185b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::mrk_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indent  or dedent  in pattern found: should check and update indent stops </p>

</div>
</div>
<a class="anchor" id="adfeefc270fb9f89da7122f1cea86872c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stack&lt;<a class="el" href="classreflex_1_1_matcher.html#a9748ab7e9dc48d3893968f432a3f7cfa">Stops</a>&gt; reflex::Matcher::stk_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stack to push/pop stops </p>

</div>
</div>
<a class="anchor" id="a414c28bfea74537044bee654cb413820"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_matcher.html#a9748ab7e9dc48d3893968f432a3f7cfa">Stops</a> reflex::Matcher::tab_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tab stops set by detecting indent margins </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="matcher_8h.html">matcher.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Sun Sep 29 2019 17:26:05 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
